<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Plateforme d'Integration RH - Bienvenue</title>
    <meta name="description" content="Systeme de gestion complete pour l'integration des nouveaux employes">
    <link rel="stylesheet" href="/css/tailwind.css">
    <link rel="stylesheet" href="/css/themes.css">
    <!-- CRITICAL: React et Supabase en premier (bloquants mais necessaires) -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <!-- Environment config - CRITICAL pour Supabase -->
    <script src="/js/env-config.js"></script>
    <!-- Babel - DOIT etre charge avant le script type="text/babel" -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Fix for "exports is not defined" error when Babel transpiles modules -->
    <script>
        // Polyfill for CommonJS to prevent Babel and library errors
        // MUST run before any Babel transpilation or libraries
        (function() {
            if (typeof window.exports === 'undefined') {
                window.exports = {};
            }
            if (typeof window.module === 'undefined') {
                window.module = { exports: window.exports };
            }

            //  FIX: Add require() polyfill for react-grid-layout
            if (typeof window.require === 'undefined') {
                window.require = function(moduleName) {
                    // Return window globals for known modules
                    const modules = {
                        'react': window.React,
                        'react-dom': window.ReactDOM,
                        'prop-types': window.PropTypes || {}
                    };
                    return modules[moduleName] || {};
                };
            }

            // Also make available in global scope for Babel
            self.exports = window.exports;
            self.module = window.module;
            self.require = window.require;
        })();
    </script>

    <!-- Scripts non-critiques - Charges en arriere-plan avec defer -->
    <script src="./caroline-plan-data.js" defer></script>
    <!-- email-template.js DOIT etre charge avant le script Babel pour que window.generateEmailHTML soit disponible -->
    <script src="./email-template.js"></script>
    <!-- Emma Client SDK - Charge en arriere-plan (non-bloquant) -->
    <script type="module">
        // Charger Emma Client APRES le rendu initial pour ne pas bloquer
        (async () => {
            try {
                const { EmmaClient } = await import('/lib/emma-client.js');
                window.EmmaClient = EmmaClient;
                // Attendre que la page soit prete avant d'initialiser
                if (document.readyState === 'loading') {
                    document.addEventListener('DOMContentLoaded', () => {
                        setTimeout(() => {
                            window.emmaRHClient = new EmmaClient({ 
                                appName: 'bienvenue', 
                                mode: 'auto'
                            });
                            console.log(' Emma Client loaded for Bienvenue');
                        }, 500);
                    });
                } else {
                    setTimeout(() => {
                        window.emmaRHClient = new EmmaClient({ 
                            appName: 'bienvenue', 
                            mode: 'auto'
                        });
                        console.log(' Emma Client loaded for Bienvenue');
                    }, 500);
                }
            } catch (e) {
                console.warn('Emma Client loading delayed:', e);
            }
        })();
    </script>
    <style>
        @media print {
            .no-print, button, .toolbar, .admin-panel, .save-indicator, .header-controls, .toggle-view { display: none !important; }
            body { background: white; color: black; -webkit-print-color-adjust: exact; print-color-adjust: exact; }
            .task-card { break-inside: avoid; border: 1px solid #ddd; box-shadow: none; margin-bottom: 10px; }
            .phase-section { break-inside: avoid; page-break-after: auto; }
            .app-container { max-width: 100%; margin: 0; padding: 0; }
            ::-webkit-scrollbar { display: none; }
            h1 { font-size: 24px; color: black; }
        }
        .gradient-bg { background: linear-gradient(135deg, #1e3a8a 0%, #1e40af 50%, #4338ca 100%); }
        .glass { background: rgba(255, 255, 255, 0.1); -webkit-backdrop-filter: blur(10px); backdrop-filter: blur(10px); }
        .chat-bubble { animation: fadeIn 0.3s ease-out; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.05); } }
        .online-dot { animation: pulse 2s infinite; }
        @keyframes bounceIn {
            0% { transform: scale(0.3); opacity: 0; }
            50% { transform: scale(1.05); }
            70% { transform: scale(0.9); }
            100% { transform: scale(1); opacity: 1; }
        }
        .animate-bounce-in { animation: bounceIn 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55); }
        .animate-pulse-slow { animation: pulse 3s infinite; }
        
        /* New Animations */
        @keyframes fadeInUp {
            from { opacity: 0; transform: translateY(20px) scale(0.95); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }
        @keyframes fadeOutDown {
            from { opacity: 1; transform: translateY(0) scale(1); }
            to { opacity: 0; transform: translateY(20px) scale(0.95); }
        }
        @keyframes slideInRight {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        .animate-fade-in-up { animation: fadeInUp 0.3s cubic-bezier(0.16, 1, 0.3, 1) forwards; }
        .animate-fade-out-down { animation: fadeOutDown 0.2s cubic-bezier(0.16, 1, 0.3, 1) forwards; }
        .animate-slide-in-right { animation: slideInRight 0.3s ease-out forwards; }
        /* Inline editing styles */
        .editable { cursor: pointer; border-bottom: 1px dashed transparent; transition: all 0.2s; }
        .editable:hover { border-bottom-color: #3b82f6; background: rgba(59,130,246,0.05); }
        .editable-input { background: white; border: 2px solid #3b82f6; border-radius: 4px; padding: 2px 6px; outline: none; }
        /* Drag and drop styles */
        .draggable { cursor: grab; }
        .draggable:active { cursor: grabbing; }
        .dragging { opacity: 0.5; transform: scale(1.02); }
        .drag-over { border: 2px dashed #3b82f6 !important; background: rgba(59,130,246,0.1) !important; }
        .drop-zone { transition: all 0.2s; }
        /* Collapse styles */
        .collapsible-content { overflow: hidden; transition: max-height 0.3s ease-out, opacity 0.2s; }
        .collapsed { max-height: 0 !important; opacity: 0; padding: 0 !important; }
        .chevron-rotate { transition: transform 0.2s; }
        .chevron-down { transform: rotate(0deg); }
        .chevron-right { transform: rotate(-90deg); }
        /* Visual enhancements */
        .priority-indicator { width: 4px; border-radius: 4px; }
        .progress-ring { transform: rotate(-90deg); }
        .task-hover:hover { transform: translateX(4px); box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
        .add-btn { opacity: 0.6; transition: opacity 0.2s; }
        .add-btn:hover { opacity: 1; }
    </style>
</head>
<body class="min-h-screen bg-gradient-to-br from-slate-50 via-blue-50 to-indigo-50">
    <!-- Loading screen shown while React/Babel initializes -->
    <!-- OPTIMISE: Image de fond chargee en lazy pour ne pas bloquer -->
    <div id="loading-screen" class="fixed inset-0 bg-gray-900 z-[200] flex items-center justify-center">
        <div class="absolute inset-0 bg-gray-900/80 backdrop-blur-sm"></div>
        <!-- Image chargee en arriere-plan apres le rendu -->
        <div id="loading-bg" class="absolute inset-0 bg-cover bg-center opacity-0 transition-opacity duration-500" style="background-image: url('https://images.unsplash.com/photo-1497215728101-856f4ea42174?ixlib=rb-1.2.1&auto=format&fit=crop&w=1950&q=80');"></div>
        <div class="relative text-center">
            <div class="w-24 h-24 mx-auto mb-6 rounded-full border-4 border-white shadow-lg overflow-hidden animate-pulse">
                <img src="/images/emma-avatar-new.jpg" alt="Emma RH" class="w-full h-full object-cover" onerror="this.style.display='none'"/>
            </div>
            <h1 class="text-2xl font-bold text-white mb-2">Portail Emma RH</h1>
            <p class="text-blue-300 font-medium mb-4">Chargement...</p>
            <div class="w-48 h-1 bg-gray-700 rounded-full mx-auto overflow-hidden">
                <div class="h-full bg-blue-500 rounded-full animate-loading-bar"></div>
            </div>
        </div>
    </div>
    <style>
        @keyframes loading-bar { 
            0% { width: 0; } 
            50% { width: 70%; } 
            100% { width: 100%; } 
        }
        .animate-loading-bar { animation: loading-bar 2s ease-in-out infinite; }
    </style>
    <div id="root"></div>
    
    <script type="text/babel">
        /**
         * ============================================================================
         * PLATEFORME D'INTEGRATION RH - BIENVENUE
         * ============================================================================
         * 
         * ARCHITECTURE GLOBALE:
         * ---------------------
         * Cette application React gere le parcours d'integration des nouveaux employes.
         * Elle utilise Supabase pour la persistance et la synchronisation temps reel.
         * 
         * STRUCTURE PRINCIPALE:
         * 1. UTILITAIRES CENTRALISES (lignes 144-298)
         *    - DataMapper: Conversion DB (snake_case) <-> React (camelCase)
         *    - SupabaseManager: Gestion requetes avec retry et validation
         *    - TaskManager: Generation et sauvegarde des taches
         * 
         * 2. CONFIGURATION SUPABASE (lignes 356-398)
         *    - Initialisation client Supabase avec fallbacks
         *    - Gestion des cles d'environnement
         * 
         * 3. COMPOSANT PRINCIPAL OnboardingPlatform (ligne ~1400)
         *    - Gestion etat global (employees, tasks, phases, resources)
         *    - Chargement initial parallele (ligne 1781)
         *    - Subscriptions temps reel (ligne 1839)
         *    - Generation dynamique des taches (ligne 1995)
         * 
         * 4. COMPOSANTS UI:
         *    - TaskCard: Carte de tache avec edition inline
         *    - AdminPanel: Gestion CRUD complete
         *    - EmmaChatbot: Assistant virtuel RH
         *    - KanbanView, GanttView: Vues alternatives
         * 
         * PATTERNS IMPORTANTS:
         * --------------------
         * - Optimistic Updates: Mise a jour UI immediate, rollback si erreur DB
         * - ID Temporaires: IDs negatifs pour eviter conflits lors de l'ajout
         * - Format Task ID: "employeeId-templateId" pour identifier les taches
         * - Real-time Sync: Subscriptions Supabase pour synchronisation multi-utilisateurs
         * 
         * POINTS CRITIQUES:
         * -----------------
         *   Ne JAMAIS utiliser Math.max() pour generer des IDs (conflits DB)
         *   Toujours utiliser DataMapper pour convertir DB <-> React
         *   Les subscriptions temps reel doivent demarrer APRES le chargement initial
         *   showNotification doit etre expose globalement (window.showNotification)
         *   email-template.js doit etre charge SANS defer pour etre disponible
         * 
         * DEPENDANCES:
         * -----------
         * - React 18 (CDN)
         * - Supabase JS v2 (CDN)
         * - Babel Standalone (compilation JSX inline)
         * - email-template.js (generation HTML email)
         * 
         * ============================================================================
         */
        
        const { useState, useMemo, useEffect, useRef } = React;

        // ============================================================================
        //  SYSTEME OPTIMISE - UTILITAIRES CENTRALISES
        // ============================================================================
        
        /**
         * DataMapper - Conversion DB <-> React
         * -----------------------------------
         * Centralise toutes les conversions entre le format base de donnees (snake_case)
         * et le format React (camelCase). CRITIQUE pour eviter les erreurs de mapping.
         * 
         * UTILISATION:
         * - Lors du chargement depuis Supabase: DataMapper.xxxToReact(dbData)
         * - Lors de la sauvegarde vers Supabase: DataMapper.xxxToDB(reactData)
         * 
         *   Ne jamais mapper manuellement - toujours utiliser DataMapper
         */
        const DataMapper = {
            // Employee
            employeeToReact: (db) => {
                // Forcer la date de debut a etre au minimum 2026-01-01
                let startDate = db.start_date || '2026-01-01';
                if (startDate) {
                    const date = new Date(startDate);
                    const minDate2026 = new Date('2026-01-01');
                    if (date < minDate2026) {
                        startDate = '2026-01-01';
                    }
                }
                return {
                    ...db,
                    avatarUrl: db.avatar_url || (db.name?.includes('Caroline') ? '/images/caroline_avatar.jpg' : null),
                    startDate: startDate
                };
            },
            employeeToDB: (react) => ({
                name: react.name,
                role: react.role,
                email: react.email,
                start_date: react.startDate,
                avatar_url: react.avatarUrl
            }),
            
            // Resource
            resourceToReact: (db) => ({
                ...db,
                avatar: db.avatar_initials,
                displayOrder: db.display_order
            }),
            resourceToDB: (react) => ({
                name: react.name,
                role: react.role,
                email: react.email,
                avatar_initials: react.avatar,
                display_order: react.displayOrder
            }),
            
            // Phase
            phaseToReact: (db) => ({
                ...db,
                startOffset: db.start_offset,
                displayOrder: db.display_order
            }),
            phaseToDB: (react) => ({
                name: react.name,
                color: react.color,
                duration: react.duration,
                start_offset: react.startOffset,
                display_order: react.displayOrder
            }),
            
            // Task Template
            taskTemplateToReact: (db) => ({
                ...db,
                phaseId: db.phase_id,
                dayOffset: db.day_offset, // Retrocompatibilite
                startDate: db.start_date || db.startDate,
                endDate: db.end_date || db.endDate,
                assignedTo: db.assigned_to || []
            }),
            taskTemplateToDB: (react) => ({
                title: react.title,
                description: react.description,
                priority: react.priority,
                phase_id: react.phaseId,
                day_offset: react.dayOffset, // Retrocompatibilite
                start_date: react.startDate,
                end_date: react.endDate,
                assigned_to: react.assignedTo
            })
        };

        /**
         * SupabaseManager - Gestionnaire de requetes robuste
         * --------------------------------------------------
         * Fournit des methodes pour executer des requetes Supabase avec:
         * - Retry automatique en cas d'erreur temporaire
         * - Validation optionnelle avant upsert
         * - Gestion d'erreurs centralisee
         * 
         * METHODES:
         * - queryWithRetry: Execute une requete avec retry (3 tentatives par defaut)
         * - upsertWithValidation: Upsert avec validation et retry automatique
         */
        const SupabaseManager = {
            async queryWithRetry(supabaseClient, queryFn, retries = 3, delay = 1000) {
                for (let i = 0; i < retries; i++) {
                    try {
                        const result = await queryFn();
                        if (result.error) throw result.error;
                        return result;
                    } catch (error) {
                        if (i === retries - 1) throw error;
                        console.warn(` Tentative ${i + 1}/${retries} echouee, retry dans ${delay}ms...`);
                        await new Promise(resolve => setTimeout(resolve, delay));
                    }
                }
            },
            
            async upsertWithValidation(supabaseClient, table, data, conflictKey, validateFn = null) {
                if (validateFn && !validateFn(data)) {
                    throw new Error(`Validation failed for ${table}`);
                }
                
                const { data: result, error } = await this.queryWithRetry(supabaseClient, () => 
                    supabaseClient.from(table).upsert(data, { onConflict: conflictKey }).select()
                );
                
                if (error) throw error;
                if (!result || result.length === 0) {
                    throw new Error(`No data returned from ${table} upsert`);
                }
                
                return result[0];
            }
        };

        /**
         * TaskManager - Gestion centralisee des taches
         * ---------------------------------------------
         * UNE SEULE SOURCE DE VERITE pour la generation et sauvegarde des taches.
         * 
         * LOGIQUE DE GENERATION:
         * 1. Prend les taskTemplates (templates de base)
         * 2. Fusionne avec employeeTasks (statuts sauvegardes par employe)
         * 3. Calcule les dates d'echeance basees sur startDate + dayOffset
         * 4. Genere un ID composite: "employeeId-templateId"
         * 
         * FORMAT TASK ID:
         * - Format: "employeeId-templateId" (ex: "1-19")
         * - Permet d'identifier a la fois l'employe et le template
         * - templateId est extrait pour les requetes DB
         * 
         * METHODES:
         * - generateTasks: Genere les taches pour un employe (fusion template + statuts)
         * - saveTaskStatus: Sauvegarde le statut d'une tache avec retry
         */
        const TaskManager = {
            /**
             * Helper pour garantir une date minimum de 2026-01-01
             * @param {string|Date} dateStr - Date a valider
             * @returns {Date} Date garantie d'etre au minimum 2026-01-01
             */
            ensureMinDate2026(dateStr) {
                const d = new Date(dateStr || '2026-01-01');
                if (isNaN(d.getTime())) {
                    return new Date('2026-01-01');
                }
                const minDate2026 = new Date('2026-01-01');
                return d >= minDate2026 ? d : minDate2026;
            },
            
            /**
             * Helper pour forcer une date dans le 1er trimestre 2026 (2026-01-01 a 2026-03-31)
             * @param {string|Date} dateStr - Date a valider
             * @returns {Date} Date garantie d'etre dans le 1er trimestre 2026
             */
            ensureQ1_2026(dateStr) {
                const d = new Date(dateStr || '2026-01-01');
                if (isNaN(d.getTime())) {
                    return new Date('2026-01-01');
                }
                const minDate = new Date('2026-01-01');
                const maxDate = new Date('2026-03-31');
                
                // Si la date est avant 2026-01-01, utiliser 2026-01-01
                if (d < minDate) {
                    return minDate;
                }
                // Si la date est apres 2026-03-31, utiliser 2026-03-31
                if (d > maxDate) {
                    return maxDate;
                }
                return d;
            },
            
            /**
             * Genere les taches pour un employe en fusionnant templates et statuts sauvegardes
             * @param {Object} employee - Employe selectionne
             * @param {Array} taskTemplates - Templates de taches depuis la DB
             * @param {Object} employeeTasks - Map des statuts sauvegardes {employeeId: {templateId: status}}
             * @returns {Array} Taches generees avec ID composite et statuts fusionnes
             */
            generateTasks(employee, taskTemplates, employeeTasks) {
                if (!employee || !employee.id) return [];
                
                const savedStatuses = employeeTasks[employee.id] || {};
                
                return taskTemplates.map(tt => {
                    const taskKey = `${employee.id}-${tt.id}`;
                    const savedStatus = savedStatuses[tt.id] || 'pending';
                    
                    //  FIX: Utiliser les dates absolues startDate et endDate du template
                    // Si le template a startDate/endDate, les utiliser directement
                    // Sinon, calculer a partir de dayOffset (retrocompatibilite)
                    let startDate, endDate, dueDate;
                    
                    if (tt.startDate && tt.endDate) {
                        // Utiliser les dates absolues du template, mais forcer dans Q1 2026
                        startDate = this.ensureQ1_2026(tt.startDate);
                        endDate = this.ensureQ1_2026(tt.endDate);
                        // S'assurer que endDate >= startDate
                        if (endDate < startDate) {
                            endDate = startDate;
                        }
                        dueDate = endDate.toISOString().split('T')[0];
                    } else if (tt.dayOffset !== undefined) {
                        // Retrocompatibilite: calculer a partir de dayOffset, mais forcer dans Q1 2026
                        const empStart = this.ensureMinDate2026(employee.startDate);
                        const dueMs = empStart.getTime() + (tt.dayOffset || 0) * 86400000;
                        const calculatedDate = new Date(dueMs);
                        startDate = this.ensureQ1_2026(calculatedDate);
                        endDate = this.ensureQ1_2026(calculatedDate);
                        dueDate = endDate.toISOString().split('T')[0];
                    } else {
                        // Fallback: utiliser 2026-01-01
                        startDate = new Date('2026-01-01');
                        endDate = new Date('2026-01-01');
                        dueDate = '2026-01-01';
                    }
                    
                    return {
                        ...tt,
                        id: taskKey,
                        templateId: tt.id,
                        employeeId: employee.id,
                        startDate: startDate.toISOString().split('T')[0],
                        endDate: endDate.toISOString().split('T')[0],
                        dueDate: dueDate,
                        status: savedStatus
                    };
                });
            },
            
            /**
             * Sauvegarde le statut d'une tache dans employee_tasks
             * Utilise upsert pour creer ou mettre a jour le statut
             * @param {Object} supabaseClient - Client Supabase
             * @param {number} employeeId - ID de l'employe
             * @param {number} templateId - ID du template de tache
             * @param {string} newStatus - Nouveau statut ('pending', 'inProgress', 'completed')
             * @param {Function} onSuccess - Callback en cas de succes
             * @param {Function} onError - Callback en cas d'erreur
             * @returns {boolean} true si succes, false sinon
             */
            async saveTaskStatus(supabaseClient, employeeId, templateId, newStatus, onSuccess, onError) {
                if (!supabaseClient || !employeeId || !templateId) {
                    onError?.('Parametres invalides');
                    return false;
                }
                
                try {
                    const result = await SupabaseManager.upsertWithValidation(
                        supabaseClient,
                        'employee_tasks',
                        {
                            employee_id: employeeId,
                            template_id: templateId,
                            status: newStatus,
                            updated_at: new Date().toISOString()
                        },
                        'employee_id, template_id',
                        (data) => ['pending', 'inProgress', 'completed'].includes(data.status)
                    );
                    
                    console.log(` Statut sauvegarde: Emp=${employeeId}, Task=${templateId}, Status=${newStatus}`);
                    onSuccess?.(result);
                    return true;
                } catch (error) {
                    console.error(' Erreur sauvegarde statut:', error);
                    onError?.(error.message || String(error));
                    return false;
                }
            }
        };
        
        // Icones SVG
        const Icons = {
            Calendar: () => (<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>),
            CheckCircle: () => (<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg>),
            Circle: () => (<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"/></svg>),
            Clock: () => (<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>),
            AlertCircle: () => (<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="12"/><line x1="12" y1="16" x2="12.01" y2="16"/></svg>),
            User: () => (<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/><circle cx="12" cy="7" r="4"/></svg>),
            Trash: () => (<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>),
            ChevronDown: () => (<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="6 9 12 15 18 9"/></svg>),
            ChevronRight: () => (<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="9 18 15 12 9 6"/></svg>),
            Search: () => (<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></svg>),
            Download: () => (<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>),
            Upload: () => (<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>),
            Grid: () => (<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="3" y="3" width="7" height="7"/><rect x="14" y="3" width="7" height="7"/><rect x="14" y="14" width="7" height="7"/><rect x="3" y="14" width="7" height="7"/></svg>),
            Settings: () => (<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/></svg>),
            Plus: () => (<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>),
            MessageCircle: () => (<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"/></svg>),
            X: () => (<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>),
            Send: () => (<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="22" y1="2" x2="11" y2="13"/><polygon points="22 2 15 22 11 13 2 9 22 2"/></svg>),
            UserPlus: () => (<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/><circle cx="8.5" cy="7" r="4"/><line x1="20" y1="8" x2="20" y2="14"/><line x1="23" y1="11" x2="17" y2="11"/></svg>),
            Edit: () => (<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/></svg>),
            GripVertical: () => (<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><circle cx="9" cy="5" r="1"/><circle cx="9" cy="12" r="1"/><circle cx="9" cy="19" r="1"/><circle cx="15" cy="5" r="1"/><circle cx="15" cy="12" r="1"/><circle cx="15" cy="19" r="1"/></svg>),
            Minus: () => (<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><line x1="5" y1="12" x2="19" y2="12"/></svg>),
            Layout: () => (<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/><line x1="3" y1="9" x2="21" y2="9"/><line x1="9" y1="21" x2="9" y2="9"/></svg>),
            List: () => (<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="8" y1="6" x2="21" y2="6"/><line x1="8" y1="12" x2="21" y2="12"/><line x1="8" y1="18" x2="21" y2="18"/><line x1="3" y1="6" x2="3.01" y2="6"/><line x1="3" y1="12" x2="3.01" y2="12"/><line x1="3" y1="18" x2="3.01" y2="18"/></svg>),
            Book: () => (<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/></svg>),
            Save: () => (<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></svg>),
            Layers: () => (<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="12 2 2 7 12 12 22 7 12 2"/><polyline points="2 17 12 22 22 17"/><polyline points="2 12 12 17 22 12"/></svg>),
            Activity: () => (<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="22 12 18 12 15 21 9 3 6 12 2 12"/></svg>),
            Columns: () => (<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12 3h7a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-7m0-18H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h7m0-18v18"/></svg>),
            Layers: () => (<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="12 2 2 7 12 12 22 7 12 2"/><polyline points="2 17 12 22 22 17"/><polyline points="2 12 12 17 22 12"/></svg>),
            Eye: () => (<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>),
            Users: () => (<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M23 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></svg>),
            Copy: () => (<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>),
        };

        // Error Boundary Simple
        class ErrorBoundary extends React.Component {
            constructor(props) { super(props); this.state = { hasError: false, error: null }; }
            static getDerivedStateFromError(error) { return { hasError: true, error }; }
            componentDidCatch(error, errorInfo) { console.error("Uncaught error:", error, errorInfo); }
            render() {
                if (this.state.hasError) {
                    return (
                        <div className="p-10 text-center">
                            <h1 className="text-2xl font-bold text-red-600 mb-4">Une erreur est survenue </h1>
                            <pre className="text-left bg-gray-100 p-4 rounded overflow-auto max-w-2xl mx-auto text-xs">{this.state.error && this.state.error.toString()}</pre>
                            <button onClick={() => window.location.reload()} className="mt-4 px-4 py-2 bg-blue-600 text-white rounded">Recharger la page</button>
                        </div>
                    );
                }
                return this.props.children;
            }
        }

        // ============================================
        // SUPABASE CONFIGURATION
        // ============================================
        // ============================================
        // SUPABASE CONFIGURATION (Environment-based with fallback)
        // ============================================
        // Get config from window (injected by Vercel/build) or use hardcoded anon key
        const SUPABASE_URL = window.SUPABASE_URL || 'https://boyuxgdplbpkknplxbxp.supabase.co';
        // Get key from env-config.js (injected by Vercel)
        const SUPABASE_KEY = window.SUPABASE_ANON_KEY || window.ENV_CONFIG?.SUPABASE_ANON_KEY;
        if (!SUPABASE_KEY) {
            console.error(' SUPABASE_ANON_KEY not configured. Check env-config.js or Vercel env vars.');
        }
        
        let supabase;
        try {
            if (SUPABASE_KEY) {
                // The CDN script exposes supabase as a global variable
                // Check both window.supabase and global supabase
                const supabaseModule = (typeof window !== 'undefined' && window.supabase) || (typeof supabase !== 'undefined' ? supabase : null);
                
                if (supabaseModule && typeof supabaseModule.createClient === 'function') {
                    supabase = supabaseModule.createClient(SUPABASE_URL, SUPABASE_KEY);
                    //  FIX: Exposer le module Supabase globalement pour emma-client.js
                    // Le CDN expose deja window.supabase comme module, mais on s'assure qu'il est disponible
                    if (!window.supabase) {
                        window.supabase = supabaseModule;
                    }
                    window.supabaseClient = supabase; // Exposer aussi le client pour usage direct
                    console.log(' Supabase client initialized');
                } else {
                    console.warn(' Supabase module not found. Make sure the CDN script is loaded before this code.');
                }
            } else {
                console.warn(' SUPABASE_ANON_KEY not configured. Supabase features disabled.');
            }
        } catch (e) {
            console.error("Supabase init error:", e);
        }

        const useSupabase = !!supabase;

        // Donnees initiales par defaut (VIDE pour migration DB)
        const triggerConfetti = () => {
            const colors = ['#3B82F6', '#10B981', '#F59E0B', '#EF4444', '#8B5CF6'];
            for (let i = 0; i < 150; i++) {
                const el = document.createElement('div');
                el.style.position = 'fixed';
                el.style.left = Math.random() * 100 + 'vw';
                el.style.top = '-20px';
                el.style.width = Math.random() * 10 + 5 + 'px';
                el.style.height = Math.random() * 10 + 5 + 'px';
                el.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                el.style.borderRadius = Math.random() > 0.5 ? '50%' : '2px';
                el.style.zIndex = '9999';
                el.style.pointerEvents = 'none';
                el.style.transition = `top ${Math.random() * 2 + 3}s ease-in, transform ${Math.random() * 2 + 3}s linear`;
                document.body.appendChild(el);
                
                requestAnimationFrame(() => {
                    el.style.top = '110vh';
                    el.style.transform = `rotate(${Math.random() * 720}deg) translateX(${Math.random() * 100 - 50}px)`;
                });
                setTimeout(() => el.remove(), 5000);
            }
        };

        const defaultEmployees = [];
        const defaultResources = [
            { id: 1, name: 'Jean-Pierre Ouellet', role: 'Directeur', email: 'jpo@gob.com', avatar: 'JP' },
            { id: 2, name: 'Marc Bolduc', role: 'Directeur', email: 'mb@gob.com', avatar: 'MB' },
            { id: 3, name: 'Emma', role: 'Responsable RH', email: 'emma@gob.com', avatar: 'EM' },
            { id: 4, name: 'Support TI', role: 'Support Technique', email: 'ti@gob.com', avatar: 'TI' },
            { id: 5, name: 'Vincent', role: 'Expert & Formation', email: 'vincent@gob.com', avatar: 'VI' },
            { id: 6, name: 'Catherine', role: 'Communication', email: 'catherine@gob.com', avatar: 'CA' },
            { id: 7, name: 'Melinda', role: 'Trading', email: 'melinda@gob.com', avatar: 'ME' },
            { id: 8, name: 'Marie-Helene Lacroix', role: 'Mentorat planif et legal', email: 'mhl@gob.com', avatar: 'MH' },
            { id: 9, name: 'Hugo', role: 'Conseiller', email: 'hugo@gob.com', avatar: 'HU' },
            { id: 10, name: 'Jonathan', role: 'Direction - Coordination - Conseiller', email: 'jonathan@gob.com', avatar: 'JO' },
            { id: 11, name: 'Jean-Christophe', role: 'Assistant en planif - RapportGOB', email: 'jc@gob.com', avatar: 'JC' },
            { id: 12, name: 'Julien', role: 'Responsable DDA - Conseiller', email: 'julien@gob.com', avatar: 'JU' },
            { id: 13, name: 'Maxime', role: 'Conseiller', email: 'maxime@gob.com', avatar: 'MA' },
            { id: 14, name: 'Mirella', role: 'Directrice succursale', email: 'mirella@gob.com', avatar: 'MI' },
            { id: 15, name: 'Marie-Eve', role: 'Gestionnaire', email: 'marieeve@gob.com', avatar: 'ME' }
        ];

        const defaultPhases = [
            { id: 1, name: 'Phase 1 : Logistique & Installation', description: 'Configuration des acces et materiel', duration: 2, startOffset: 0, color: '#3B82F6', order: 1 },
            { id: 2, name: 'Phase 2 : Formation de base', description: 'Decouverte des outils et processus', duration: 5, startOffset: 2, color: '#10B981', order: 2 },
            { id: 3, name: 'Phase 3 : Immersion terrain', description: 'Observation et premiers dossiers', duration: 10, startOffset: 7, color: '#8B5CF6', order: 3 },
            { id: 4, name: 'Phase 4 : Autonomie supervisee', description: 'Gestion de dossiers avec validation', duration: 20, startOffset: 17, color: '#F59E0B', order: 4 }
        ];

        const defaultTaskTemplates = [
            // Phase 1 - Arrivee & Logistique (Janvier 2026)
            { id: 1, phaseId: 1, title: 'Recuperation du materiel informatique', description: 'Recuperer l\'ordinateur portable, l\'ecran et les peripheriques au departement TI (2e etage).', priority: 'high', category: 'materiel', startDate: '2026-01-02', endDate: '2026-01-02', assignedTo: [3] },
            { id: 2, phaseId: 1, title: 'Configuration des acces courriels', description: 'Configuration d\'Outlook, de la signature corporative et des acces aux calendriers partages.', priority: 'high', category: 'technique', startDate: '2026-01-02', endDate: '2026-01-03', assignedTo: [4] },
            { id: 3, phaseId: 1, title: 'Visite des locaux et presentation', description: 'Tour complet des bureaux, localisation des issues de secours, cafeteria et presentation aux equipes presentes.', priority: 'low', category: 'social', startDate: '2026-01-02', endDate: '2026-01-02', assignedTo: [3] },
            
            // Phase 1 - J2 (Janvier 2026)
            { id: 4, phaseId: 1, title: 'Rencontre d\'introduction equipe', description: 'Rencontre informelle avec les membres de l\'equipe immediate pour briser la glace.', priority: 'medium', category: 'social', startDate: '2026-01-03', endDate: '2026-01-03', assignedTo: [1, 2] },
            { id: 5, phaseId: 1, title: 'Formation CRM & Outils', description: 'Session de formation initiale sur le CRM, la gestion documentaire et les outils de communication.', priority: 'high', category: 'technique', startDate: '2026-01-03', endDate: '2026-01-05', assignedTo: [4] },

            // Phase 2 - Formation (Janvier-Fevrier 2026)
            { id: 6, phaseId: 2, title: 'Formation Conformite & Ethique', description: 'Completer les modules obligatoires sur la conformite, le code d\'ethique et la securite de l\'information.', priority: 'high', category: 'formation', startDate: '2026-01-06', endDate: '2026-01-08', assignedTo: [3] },
            { id: 7, phaseId: 2, title: 'Formation Gamme de Produits', description: 'Vue d\'ensemble detaillee des produits et services offerts, avec focus sur les nouveautes.', priority: 'medium', category: 'formation', startDate: '2026-01-09', endDate: '2026-01-10', assignedTo: [1] },
            { id: 11, phaseId: 2, title: 'Histoire GOB & Style d\'Investissement', description: 'Presentation par Vincent sur l\'histoire du groupe et la philosophie d\'investissement.', priority: 'high', category: 'formation', startDate: '2026-01-13', endDate: '2026-01-14', assignedTo: [5] },
            { id: 12, phaseId: 2, title: 'Les Modeles en Gestion Discretionnaire (GD)', description: 'Explication detaillee des modeles de gestion discretionnaire par Vincent.', priority: 'high', category: 'formation', startDate: '2026-01-15', endDate: '2026-01-17', assignedTo: [5] },
            { id: 13, phaseId: 2, title: 'Outils : Calculs GD & Tableaux de Bord', description: 'Session pratique avec Vincent sur les outils de calcul et le tableau de bord.', priority: 'high', category: 'technique', startDate: '2026-01-20', endDate: '2026-01-22', assignedTo: [5] },
            { id: 14, phaseId: 2, title: 'Arborescence & Sources d\'Information', description: 'Survol des essentiels : ou trouver l\'information et comprendre l\'arborescence des dossiers.', priority: 'medium', category: 'administratif', startDate: '2026-01-23', endDate: '2026-01-24', assignedTo: [5] },
            { id: 15, phaseId: 2, title: 'Grille Tarifaire et Avantages', description: 'Explication complete de la structure tarifaire et de ses avantages concurrentiels.', priority: 'high', category: 'formation', startDate: '2026-01-27', endDate: '2026-01-28', assignedTo: [5] },
            { id: 16, phaseId: 2, title: 'Presentation "Nouveau Client"', description: 'Detail du contenu et de la structure de la presentation type pour un nouveau client.', priority: 'high', category: 'formation', startDate: '2026-01-29', endDate: '2026-01-31', assignedTo: [5] },

            // Phase 2 continuation (Fevrier 2026)
            { id: 8, phaseId: 2, title: 'Atelier Tableaux de Bord', description: 'Formation pratique sur l\'utilisation et l\'interpretation des tableaux de bord de performance.', priority: 'medium', category: 'technique', startDate: '2026-02-03', endDate: '2026-02-05', assignedTo: [4] },

            // Phase 3 - Immersion (Fevrier-Mars 2026)
            { id: 9, phaseId: 3, title: 'Observation RDV Client (Senior)', description: 'Accompagnement d\'un conseiller senior lors d\'une rencontre client pour observation des bonnes pratiques.', priority: 'high', category: 'pratique', startDate: '2026-02-10', endDate: '2026-02-14', assignedTo: [1] },
            { id: 10, phaseId: 3, title: 'Simulation Dossier Client', description: 'Realisation complete d\'un dossier client fictif pour valider l\'acquisition des competences.', priority: 'medium', category: 'pratique', startDate: '2026-02-17', endDate: '2026-02-21', assignedTo: [2] },
            
            // Phase 3 - Tours de roue (Mars 2026)
            { id: 17, phaseId: 3, title: 'Tour de Roue : Communication', description: 'Session d\'immersion avec Catherine sur le volet Communication et Marketing.', priority: 'medium', category: 'formation', startDate: '2026-03-03', endDate: '2026-03-05', assignedTo: [6] },
            { id: 18, phaseId: 3, title: 'Tour de Roue : Trading', description: 'Session d\'immersion avec Melinda sur le fonctionnement du desk de Trading.', priority: 'medium', category: 'technique', startDate: '2026-03-10', endDate: '2026-03-12', assignedTo: [7] }
        ];

        // Categories disponibles pour les taches
        const taskCategories = ['administratif', 'technique', 'formation', 'pratique', 'suivi', 'autre'];

        // Templates de role predefinis
        const roleTemplates = {
            'patrimoine': { name: 'Conseiller en gestion de patrimoine', phases: [1, 2, 3, 4] },
            'analyste': { name: 'Analyste financier', phases: [1, 2, 3, 4] },
            'admin': { name: 'Adjointe administrative', phases: [1, 2, 3] },
            'custom': { name: 'Personnalise', phases: [1, 2, 3, 4] }
        };

        // ... (Chatbot code) ...

        // Login Component
        // Chatbot Emma RH
        // Chatbot Emma RH
        // Chatbot Ultra-Intelligent Emma RH
        /**
         * ============================================================================
         * MODULE: ULTRA-INTELLIGENT EMMA CHATBOT
         * ============================================================================
         * 
         * ARCHITECTURE:
         * ------------
         * Assistant virtuel RH entierement cote client (browser).
         * Utilise "Context Injection" - passe l'etat brut (tasks, phases, employees)
         * directement dans la logique d'analyse (getEmmaResponse).
         * 
         * POURQUOI PAS DE BACKEND?
         * -------------------------
         * Pour garder le deploiement simple (HTML statique), on utilise une logique
         * heuristique au lieu d'un vrai LLM. La fonction getEmmaResponse parse les
         * mots-cles et verifie les tableaux de donnees pour generer des reponses "intelligentes".
         * 
         * FONCTIONNALITES:
         * ---------------
         * - Reponses contextuelles basees sur l'etat actuel (taches, phases, employe)
         * - Suggestions pre-definies pour guider l'utilisateur
         * - Integration avec EmmaClient SDK (si disponible) pour reponses avancees
         * - Fallback local pour questions HR specifiques (donnees sensibles)
         * 
         * CONNAISSANCES & APPRENTISSAGES:
         * -------------------------------
         * 1. Syntaxe JSX: Tous les elements adjacents doivent etre wrappes dans <> ou <div>
         * 2. Minification React: Avec CDN, les scripts inline doivent etre parfaitement valides
         * 3. Injection d'etat: Passer beaucoup de donnees (objets complets) fonctionne ici
         *    mais verifier les performances si on scale
         * 
         * ============================================================================
         */
        
        const EmmaChatbot = ({ employee, tasks, phases, resources }) => {
            // State to control chatbot visibility
            const [isOpen, setIsOpen] = useState(true);
            const [isClosing, setIsClosing] = useState(false); // New state for exit animation
            
            // State to store chat messages (only user conversations, not the greeting)
            const [conversationMessages, setConversationMessages] = useState([]);
            // State for the user's input message
            const [input, setInput] = useState('');
            // Ref to scroll to the bottom of the chat messages
            const messagesEndRef = useRef(null);

            // Compute Emma's greeting dynamically based on current props
            const emmaGreeting = useMemo(() => {
                const name = employee?.name && employee.name !== 'Chargement...' ? employee.name.split(' ')[0] : '';
                return `Bonjour ${name} ! Je suis Emma RH, assistante virtuelle RH. Comment puis-je vous aider aujourd'hui au sujet de votre integration aujourd'hui ?`;
            }, [employee?.name]);

            // Combine the greeting with conversation messages for display
            const messages = useMemo(() => [
                { from: 'emma', text: emmaGreeting },
                ...conversationMessages
            ], [emmaGreeting, conversationMessages]);

            // Effect to scroll to the latest message whenever messages state changes
            const scrollToBottom = () => { messagesEndRef.current?.scrollIntoView({ behavior: "smooth" }); };
            useEffect(() => { scrollToBottom(); }, [messages]);

            const suggestions = [
                " Mon avancement ?",
                " Ai-je du retard ?",
                " Qui contacter ?",
                " Mes prochaines taches ?",
                " Question RH"
            ];

            // CORE AI LOGIC: Uses EmmaClient SDK with local HR-aware fallback
            // This function processes user questions via the unified Emma API
            const getEmmaResponse = async (question) => {
                const q = question.toLowerCase(); // Normalize for local processing
                const pending = tasks.filter(t => t.status === 'pending');
                const late = pending.filter(t => t.dueDate < new Date().toISOString().split('T')[0]);
                const nextPhase = phases.find(p => tasks.some(t => t.phaseId === p.id && t.status === 'pending'));
                
                // LOCAL HR-SPECIFIC LOGIC (sensitive data - never sent to external API)
                // These questions relate to the employee's personal onboarding data
                if (q.includes('retard') || q.includes('late') || q.includes('urgence') || q.includes('probleme')) {
                    if (late.length > 0) {
                        return ` Vigilance : ${late.length} taches necessitent votre attention, notamment "${late[0].title}".`;
                    }
                    return " Tout est sous controle. Aucun retard detecte.";
                }
                
                if (q.includes('qui') || q.includes('contact') || q.includes('responsable')) {
                    const foundRes = resources.find(r => q.includes(r.name.toLowerCase()));
                    if (foundRes) return ` **${foundRes.name}** (${foundRes.role}) est disponible via ${foundRes.email || 'email'}.`;
                    if (q.includes('admin') || q.includes('it')) {
                        const tech = resources.find(r => r.role.toLowerCase().includes('it') || r.role.toLowerCase().includes('tech'));
                        return tech ? ` Support IT : Contactez **${tech.name}**.` : "Je ne trouve pas de contact IT specifique.";
                    }
                    return ` Vos contacts cles :\n${resources.map(r => `- ${r.name} (${r.role})`).join('\n')}`;
                }
                
                if (q.includes('suite') || q.includes('prochain') || q.includes('demain')) {
                    if (nextPhase) {
                        const nextTasks = tasks.filter(t => t.phaseId === nextPhase.id && t.status === 'pending').slice(0, 3);
                        return ` Prevision : Vous entrez dans la phase "${nextPhase.name}". Voici vos 3 priorites strategiques :\n${nextTasks.map(t => ` ${t.title}`).join('\n')}`;
                    }
                    return " Vous avez atteint l'horizon des evenements ! Tout est complete.";
                }
                
                if (q.includes('synthese') || q.includes('resume') || q.includes('audit') || q.includes('avancement')) {
                    const completionRate = Math.round((tasks.filter(t => t.status === 'completed').length / tasks.length) * 100);
                    return ` **Audit d'Integration**\n- Score Global : ${completionRate}/100\n- Rapidite : ${late.length === 0 ? 'Excellente ' : 'Attention requise '}\n- Prochaine etape critique : ${pending[0]?.title || 'Aucune'}\n\nMon conseil : Continuez sur cette lancee !`;
                }
                
                // EXTERNAL AI for general questions (non-sensitive)
                // Try to use the Emma API for intelligent responses
                if (window.emmaRHClient) {
                    try {
                        const result = await window.emmaRHClient.chat(question, {
                            context: { 
                                appContext: 'hr-onboarding',
                                employeeName: employee?.name,
                                tasksCount: tasks.length,
                                phasesCount: phases.length
                            }
                        });
                        if (result.success && result.text) {
                            return result.text;
                        }
                    } catch (err) {
                        console.warn('Emma API unavailable, using local fallback:', err);
                    }
                }
                
                // FALLBACK: Generic response
                return " Interessant. Pourriez-vous preciser si cela concerne une tache, un contact ou votre planning global ?";
            };

            // State for loading indicator
            const [isLoading, setIsLoading] = useState(false);

            // Handles sending a message from the user
            const handleSend = async (messageText = null) => {
                const textToSend = typeof messageText === 'string' ? messageText : input;
                if (!textToSend.trim() || isLoading) return;
                
                const userMsg = { from: 'user', text: textToSend };
                setConversationMessages(prev => [...prev, userMsg]);
                
                if (!messageText) setInput('');
                
                setIsLoading(true);
                try {
                    const response = await getEmmaResponse(textToSend);
                    setConversationMessages(prev => [...prev, { from: 'emma', text: response }]);
                } catch (err) {
                    setConversationMessages(prev => [...prev, { from: 'emma', text: "Desolee, j'ai rencontre une erreur. Reessayez." }]);
                } finally {
                    setIsLoading(false);
                }
            };
            
            // Handle closing with animation
            const handleClose = () => {
                setIsClosing(true);
                setTimeout(() => {
                    setIsOpen(false);
                    setIsClosing(false);
                }, 200); // 200ms matches animation duration
            };
            
            // Handle opening
            const handleOpen = () => {
                setIsOpen(true);
            };

            return (
                <div className="fixed bottom-6 right-6 z-50 flex flex-col items-end pointer-events-none">
                     {/* Chat Window */}
                     {(isOpen || isClosing) && (
                        <div className={`pointer-events-auto bg-white rounded-2xl shadow-2xl border border-gray-200 w-80 sm:w-96 flex flex-col overflow-hidden transition-all duration-300 origin-bottom-right mb-4 ${isClosing ? 'opacity-0 scale-95 translate-y-4' : 'opacity-100 scale-100 translate-y-0'}`} style={{ height: '400px' }}>
                            {/* Header */}
                            <div className="bg-gradient-to-r from-purple-700 to-indigo-700 p-4 text-white flex justify-between items-center shrink-0">
                                <div className="flex items-center gap-3">
                                    <div className="relative">
                                        <div className="w-10 h-10 bg-white/20 rounded-full flex items-center justify-center overflow-hidden border-2 border-white/30 backdrop-blur-sm">
                                            <img src="/images/emma-avatar-new.jpg" alt="Emma" className="w-full h-full object-cover" />
                                        </div>
                                        <div className="absolute bottom-0 right-0 w-3 h-3 bg-green-400 rounded-full border-2 border-purple-700"></div>
                                    </div>
                                    <div>
                                        <div className="font-bold">Emma</div>
                                        <div className="text-xs text-purple-200">Assistant RH Senior</div>
                                    </div>
                                </div>
                                <button onClick={handleClose} className="text-white/80 hover:text-white p-1 hover:bg-white/10 rounded"><Icons.X /></button>
                            </div>
                            
                            {/* Messages Area */}
                            <div className="flex-1 overflow-y-auto p-4 space-y-3 bg-gray-50">
                                {messages.map((msg, i) => (
                                    <div key={i} className={`flex ${msg.from === 'user' ? 'justify-end' : 'justify-start'}`}>
                                        <div className={`max-w-[85%] p-3 rounded-2xl text-sm ${msg.from === 'user' ? 'bg-purple-600 text-white rounded-br-none' : 'bg-white shadow-sm border border-gray-100 text-gray-700 rounded-bl-none'}`}>
                                            <div className="whitespace-pre-wrap">{msg.text}</div>
                                        </div>
                                    </div>
                                ))}
                                {isLoading && (
                                    <div className="flex justify-start">
                                        <div className="bg-white shadow-sm border border-gray-100 p-3 rounded-2xl rounded-bl-none">
                                            <div className="flex gap-1">
                                                <div className="w-2 h-2 bg-purple-400 rounded-full animate-bounce"></div>
                                                <div className="w-2 h-2 bg-purple-400 rounded-full animate-bounce" style={{animationDelay: '0.1s'}}></div>
                                                <div className="w-2 h-2 bg-purple-400 rounded-full animate-bounce" style={{animationDelay: '0.2s'}}></div>
                                            </div>
                                        </div>
                                    </div>
                                )}
                            <div ref={messagesEndRef} />
                            </div>

                            {/* Suggestions Area */}
                            <div className="px-4 pt-2 pb-0 bg-gray-50 flex gap-2 overflow-x-auto no-scrollbar mask-gradient">
                                {suggestions.map((s, i) => (
                                    <button 
                                        key={i} 
                                        onClick={() => handleSend(s)}
                                        className="whitespace-nowrap px-3 py-1.5 bg-white border border-purple-200 text-purple-700 rounded-full text-xs font-medium hover:bg-purple-50 transition-colors shadow-sm shrink-0"
                                    >
                                        {s}
                                    </button>
                                ))}
                            </div>

                            {/* Input Area */}
                            <div className="p-3 bg-white border-t flex gap-2 shrink-0">
                                <input 
                                    className="flex-1 bg-gray-100 rounded-full px-4 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-purple-500 transition-all"
                                    placeholder="Posez une question..."
                                    value={input}
                                    onChange={e => setInput(e.target.value)}
                                    onKeyPress={e => e.key === 'Enter' && handleSend()}
                                />
                                <button onClick={() => handleSend()} className="w-10 h-10 bg-purple-600 text-white rounded-full flex items-center justify-center hover:bg-purple-700 transition-transform active:scale-95 shadow-lg"><Icons.Send /></button>
                            </div>
                        </div>

                     )}
                     {(!isOpen && !isClosing) && (
                         <button onClick={handleOpen} className="pointer-events-auto group flex items-center gap-2 bg-gradient-to-r from-purple-600 to-indigo-600 text-white pl-4 pr-1 py-1 rounded-full shadow-xl hover:shadow-2xl transition-all hover:-translate-y-1">
                             <span className="font-bold text-sm hidden sm:inline">Besoin d'aide ?</span>
                             <span className="font-bold text-sm sm:hidden">Emma</span>
                             <div className="w-10 h-10 bg-white/20 rounded-full flex items-center justify-center group-hover:bg-white/30 transition-colors"><Icons.MessageCircle /></div>
                         </button>
                     )}
                </div>
            );
        };

        // Email Prompt Modal Component (replaces prompt())
        const EmailPromptModal = ({ isOpen, onClose, onConfirm, defaultValue = 'projetsjsl@gmail.com' }) => {
            const [email, setEmail] = useState(defaultValue);
            
            if (!isOpen) return null;
            
            const handleSubmit = (e) => {
                e.preventDefault();
                if (email && email.includes('@')) {
                    onConfirm(email);
                    onClose();
                }
            };
            
            return (
                <div className="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-[10000] p-4">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-md w-full p-6">
                        <h3 className="text-xl font-bold text-gray-900 mb-4">Entrez l'adresse email du destinataire</h3>
                        <form onSubmit={handleSubmit} className="space-y-4">
                            <input
                                type="email"
                                value={email}
                                onChange={(e) => setEmail(e.target.value)}
                                className="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none"
                                placeholder="email@exemple.com"
                                autoFocus
                            />
                            <div className="flex gap-3 justify-end">
                                <button
                                    type="button"
                                    onClick={onClose}
                                    className="px-4 py-2 text-gray-700 bg-gray-100 rounded-lg hover:bg-gray-200 transition-colors"
                                >
                                    Annuler
                                </button>
                                <button
                                    type="submit"
                                    className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors"
                                >
                                    Confirmer
                                </button>
                            </div>
                        </form>
                    </div>
                </div>
            );
        };

        // Login Component
        const LoginScreen = ({ employees, onLogin }) => {
            const [selectedEmp, setSelectedEmp] = useState(null);
            const [password, setPassword] = useState('');
            const [error, setError] = useState('');

            // Always sync with employees when they load/change
            useEffect(() => {
                if (employees.length > 0) {
                    // If no selection or current selection is invalid, select first employee
                    if (selectedEmp === null || !employees.find(e => e.id === selectedEmp)) {
                        setSelectedEmp(employees[0].id);
                    }
                }
            }, [employees]);

            const handleLogin = (e) => {
                e.preventDefault();
                // Mot de passe securise
                if (password.toLowerCase() === 'vip') {
                    onLogin(selectedEmp);
                    // Clear password after successful login
                    setPassword('');
                } else {
                    setError('Mot de passe incorrect');
                }
            };

            return (
                <div className="fixed inset-0 bg-gray-900 z-[100] flex items-center justify-center bg-[url('https://images.unsplash.com/photo-1497215728101-856f4ea42174?ixlib=rb-1.2.1&auto=format&fit=crop&w=1950&q=80')] bg-cover bg-center">
                    <div className="absolute inset-0 bg-gray-900/80 backdrop-blur-sm"></div>
                    <div className="relative bg-white p-8 rounded-2xl shadow-2xl w-full max-w-md border border-gray-100">
                        <div className="text-center mb-8">
                            <div className="w-24 h-24 mx-auto mb-4 rounded-full border-4 border-white shadow-lg overflow-hidden relative">
                                <img src="/images/emma-avatar-new.jpg" alt="Emma RH" className="w-full h-full object-cover" />
                            </div>
                            <h1 className="text-2xl font-bold text-gray-800 mb-1">Portail Emma RH</h1>
                            <p className="text-blue-500 font-medium">Bienvenue sur votre espace</p>
                        </div>

                        {error && <div className="bg-red-50 text-red-600 p-3 rounded-lg mb-6 text-sm text-center flex items-center justify-center gap-2"><Icons.AlertCircle /> {error}</div>}
                        
                        <form onSubmit={handleLogin} className="space-y-5">
                            <div>
                                <label className="block text-sm font-medium text-gray-700 mb-2">Selectionnez votre profil</label>
                                <div className="relative">
                                    <select 
                                        value={selectedEmp} 
                                        onChange={(e) => setSelectedEmp(parseInt(e.target.value))}
                                        className="w-full px-4 py-3 bg-gray-50 border border-gray-200 rounded-xl focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none appearance-none transition-all cursor-pointer font-bold text-gray-700"
                                        disabled={employees.length === 0}
                                    >
                                        {employees.length === 0 ? (
                                            <option>Aucun compte (Veuillez initialiser la DB)</option>
                                        ) : (
                                            employees.map(emp => <option key={emp.id} value={emp.id}>{emp.name}</option>)
                                        )}
                                    </select>
                                    <div className="absolute right-4 top-1/2 -translate-y-1/2 pointer-events-none text-gray-400">
                                        <Icons.ChevronDown />
                                    </div>
                                </div>
                            </div>
                            <div>
                                <label className="block text-xs font-bold text-gray-500 uppercase tracking-wide mb-2">Mot de passe</label>
                                <input 
                                    type="password"
                                    value={password}
                                    onChange={(e) => setPassword(e.target.value)}
                                    className="w-full px-4 py-3 bg-gray-50 border border-gray-200 rounded-xl focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none transition-all"
                                    placeholder="------"
                                />
                            </div>
                            <button type="submit" className="w-full bg-gradient-to-r from-blue-600 to-indigo-600 text-white py-3 rounded-xl font-bold hover:shadow-lg hover:scale-[1.02] transition-all duration-200 shadow-blue-500/30">
                                Acceder au portail
                            </button>
                        </form>

                        <div className="mt-8 pt-6 border-t border-gray-100 text-center">
                            <img src="../logojslaidark.jpg" alt="JSLAi" className="h-8 mx-auto opacity-50 grayscale hover:grayscale-0 transition-all duration-300" />
                            <p className="text-[10px] text-gray-400 mt-2">Propulse par JSLAI - Tous droits reserves</p>
                        </div>
                    </div>
                </div>
            );
        };

        // Helper function to send email with address
        const sendEmailWithAddress = async (to, subject, html, employee, showNotificationFn) => {
            // Feedback UI
            const originalText = document.activeElement ? document.activeElement.innerText : '';
            if (document.activeElement) document.activeElement.innerText = 'Envoi... ';

            try {
                const response = await fetch('/api/send-email', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        to: to,
                        subject: subject,
                        html: html
                    })
                });

                const result = await response.json();
                if (response.ok) {
                    const notifyFn = showNotificationFn || (typeof showNotification !== 'undefined' ? showNotification : console.log);
                    if (typeof notifyFn === 'function') {
                        notifyFn(`Email envoye a ${to} !`, 'success');
                    }
                    if (document.activeElement) document.activeElement.innerText = originalText;
                } else {
                    throw new Error(result.error || 'Erreur lors de l\'envoi');
                }
            } catch (error) {
                console.error('Erreur envoi email:', error);
                const notifyFn = showNotificationFn || (typeof showNotification !== 'undefined' ? showNotification : console.error);
                if (typeof notifyFn === 'function') {
                    notifyFn(`Erreur: ${error.message}`, 'error');
                } else {
                    console.error(`Erreur: ${error.message}`);
                }
                if (document.activeElement) document.activeElement.innerText = originalText;
            }
        };

        /**
         * Envoie un email via l'API Resend avec le plan d'integration
         * ------------------------------------------------------------
         * DEPENDANCES:
         * - window.generateEmailHTML: Doit etre charge depuis email-template.js
         * - window.showNotification: Expose globalement par le composant React
         * 
         * FLOW:
         * 1. Verifie que generateEmailHTML est disponible
         * 2. Genere le HTML de l'email
         * 3. Demande l'adresse email via prompt()
         * 4. Envoie via /api/send-email
         * 
         *   email-template.js doit etre charge SANS defer pour etre disponible
         * 
         * @param {Object} employee - Employe selectionne
         * @param {Array} phases - Phases d'integration
         * @param {Array} tasks - Taches de l'employe
         * @param {Array} resources - Responsables/contacts
         */
        const sendEmailViaResend = async (employee, phases, tasks, resources) => {
             // Utiliser window.showNotification si disponible, sinon fallback
             const notify = window.showNotification || ((msg, type) => {
                 if (type === 'error') console.error(msg);
                 else console.log(msg);
                 alert(msg);
             });
             
             // Verifier que generateEmailHTML est disponible
             if (typeof window.generateEmailHTML !== 'function') {
                 notify(' Le generateur d\'email n\'est pas encore charge. Attendez quelques secondes et reessayez.', 'error');
                 console.error('window.generateEmailHTML is not a function. email-template.js may not be loaded yet.');
                 return;
             }
             
             let html;
             try {
                html = window.generateEmailHTML(employee, phases, tasks, resources);
                if (!html) {
                    notify('Erreur: Impossible de generer l\'email. Verifiez les donnees.', 'error');
                    return;
                }
             } catch (e) {
                console.error("Erreur generation email:", e);
                notify(`Erreur: ${e.message || "Le modele d'email ne s'est pas charge correctement. Rechargez la page."}`, 'error');
                return;
             }
             
             // Generer un sujet par defaut si employee n'est pas defini
             const employeeName = (employee && employee.name) ? employee.name : 'Nouveau collaborateur';
             const subject = `Plan d'Integration - ${employeeName}`;
             
             const to = prompt("Entrez l'adresse email du destinataire:", "projetsjsl@gmail.com"); 
             if (!to || !to.trim()) {
                 notify('Envoi annule - adresse email requise', 'info');
                 return;
             }
             
             // Verifier que le sujet est bien defini
             if (!subject || subject.trim() === '' || subject === 'Plan d\'Integration - ') {
                 notify('Erreur: Le sujet de l\'email est manquant ou invalide', 'error');
                 console.error('Subject error:', { subject, employee, employeeName });
                 return;
             }
             
             // Feedback UI
             const originalText = document.activeElement ? document.activeElement.innerText : '';
             if (document.activeElement) document.activeElement.innerText = 'Envoi... ';

             try {
                console.log(' Envoi email:', { to: to.trim(), subject: subject.trim(), htmlLength: html.length });
                const response = await fetch('/api/send-email', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        to: to.trim(),
                        subject: subject.trim(),
                        html: html,
                        briefingType: 'onboarding_plan'
                    }),
                });

                const data = await response.json();

                if (response.ok) {
                    notify(' Email envoye avec succes !', 'success');
                } else {
                    console.error('Erreur envoi email:', data);
                    notify(` Erreur lors de l'envoi : ${data.message || 'Erreur inconnue'}`, 'error');
                }
             } catch (error) {
                console.error('Erreur reseau:', error);
                notify(` Erreur reseau lors de l'envoi de l'email: ${error.message}`, 'error');
             } finally {
                if (document.activeElement) document.activeElement.innerText = originalText;
             }
        };

        /**
         * DatePicker - Composant calendrier avec panneau modal (style similaire au panneau ressources)
         * --------------------------------------------------------------------------------------------
         * Affiche un panneau modal flottant avec un calendrier natif, similaire au panneau "Modifier ressources"
         * 
         * @param {object} props - Les proprietes du composant
         * @param {string} props.value - La valeur de la date (format YYYY-MM-DD)
         * @param {function} props.onChange - Callback appele lors du changement de date
         * @param {function} [props.onBlur] - Callback appele lorsque l'input perd le focus
         * @param {string} [props.placeholder] - Texte de placeholder
         * @param {string} [props.className] - Classes CSS additionnelles
         * @param {string} [props.min] - Date minimale autorisee (format YYYY-MM-DD)
         * @param {string} [props.max] - Date maximale autorisee (format YYYY-MM-DD)
         * @param {boolean} [props.showIcon=true] - Affiche ou non l'icone calendrier
         */
        const DatePicker = ({ value, onChange, onBlur, placeholder, className = '', min = null, max = null, showIcon = true }) => {
            const [isOpen, setIsOpen] = useState(false);
            const inputRef = useRef(null);

            const handleClick = (e) => {
                e.stopPropagation();
                setIsOpen(true);
                // Focus sur l'input pour ouvrir le calendrier natif apres le rendu
                setTimeout(() => {
                    if (inputRef.current) {
                        inputRef.current.focus();
                        // Essayer showPicker() si disponible (Chrome/Edge)
                        if (inputRef.current.showPicker) {
                            try {
                                inputRef.current.showPicker();
                            } catch (err) {
                                console.warn('showPicker() non supporte, utilisation du focus');
                            }
                        }
                    }
                }, 50);
            };

            const handleClose = () => {
                setIsOpen(false);
                if (onBlur) {
                    onBlur();
                }
            };

            const handleDateChange = (newValue) => {
                // Forcer la date a etre au minimum 2026-01-01
                const minDate = min || '2026-01-01';
                const finalValue = newValue && newValue < minDate ? minDate : newValue;
                onChange(finalValue);
                setIsOpen(false);
                if (onBlur) {
                    onBlur();
                }
            };

            const formatDate = (dateStr) => {
                if (!dateStr) return placeholder || 'Selectionner date';
                const date = new Date(dateStr);
                return date.toLocaleDateString('fr-FR', { day: '2-digit', month: '2-digit', year: 'numeric' });
            };

            return (
                <>
                    <div
                        onClick={handleClick}
                        className={`${className} cursor-pointer flex items-center gap-1 hover:bg-blue-50 transition-colors rounded px-2 py-1 border border-transparent hover:border-blue-300`}
                    >
                        {showIcon && <span></span>}
                        <span className="text-xs whitespace-nowrap">{formatDate(value)}</span>
                    </div>

                    {/* Panneau modal similaire au panneau ressources */}
                    {isOpen && (
                        <div style={{ position: 'fixed', inset: 0, zIndex: 10000, pointerEvents: 'none' }}>
                            {/* Overlay semi-transparent pour fermer en cliquant a l'exterieur */}
                            <div 
                                className="fixed inset-0 bg-black/20 backdrop-blur-sm"
                                style={{ pointerEvents: 'auto' }}
                                onClick={handleClose}
                            />
                            {/* Panneau flottant centre avec calendrier */}
                            <div 
                                className="fixed bg-white rounded-xl shadow-2xl"
                                style={{
                                    top: '50%',
                                    left: '50%',
                                    transform: 'translate(-50%, -50%)',
                                    width: '320px',
                                    maxWidth: '90vw',
                                    pointerEvents: 'auto',
                                    zIndex: 10001
                                }}
                                onClick={(e) => e.stopPropagation()}
                            >
                                {/* Header */}
                                <div className="px-4 py-3 bg-gradient-to-r from-blue-600 to-indigo-600 text-white flex items-center justify-between rounded-t-xl">
                                    <div className="flex items-center gap-2">
                                        <span className="text-xl"></span>
                                        <div className="text-sm font-bold">Selectionner une date</div>
                                    </div>
                                    <button 
                                        onClick={handleClose} 
                                        className="text-white/80 hover:text-white hover:bg-white/20 p-1.5 rounded-lg transition-colors"
                                        title="Fermer"
                                    >
                                        <Icons.X className="w-5 h-5" />
                                    </button>
                                </div>
                                
                                {/* Calendrier natif */}
                                <div className="p-4 bg-gray-50">
                                    <input
                                        ref={inputRef}
                                        type="date"
                                        value={value || '2026-01-01'}
                                        onChange={(e) => handleDateChange(e.target.value)}
                                        min={min || '2026-01-01'}
                                        max={max}
                                        className="w-full p-3 border-2 border-blue-300 rounded-lg text-center text-lg font-semibold focus:border-blue-500 focus:outline-none focus:ring-2 focus:ring-blue-200"
                                        style={{ fontSize: '16px' }}
                                    />
                                    <div className="mt-3 text-xs text-gray-500 text-center">
                                        Periode: {min || '2026-01-01'} {max ? `-> ${max}` : ''}
                                    </div>
                                </div>
                                
                                {/* Footer avec date formatee */}
                                {value && (
                                    <div className="px-4 py-3 bg-white border-t border-gray-200 rounded-b-xl">
                                        <div className="text-xs font-bold text-gray-500 uppercase mb-1">Date selectionnee :</div>
                                        <div className="text-sm font-semibold text-gray-900">{formatDate(value)}</div>
                                    </div>
                                )}
                            </div>
                        </div>
                    )}
                </>
            );
        };

        /**
         * AdminPanel - Panneau d'administration complet
         * ----------------------------------------------
         * Composant de niveau superieur pour gerer toutes les entites:
         * - Employees: CRUD complet avec upload d'avatar
         * - Resources: Gestion des responsables/contacts
         * - Phases: Gestion des phases d'integration
         * - Task Templates: Gestion des templates de taches
         * 
         * OPTIMISATION: Defini au niveau superieur pour eviter re-renders
         * inutiles du composant parent.
         * 
         * FONCTIONS INTERNES:
         * - saveTaskField: Sauvegarde un champ de template (definie dans AdminPanel)
         * - updateEmp, deleteEmp: Gestion employes
         * - updateRes, deleteRes: Gestion ressources
         * - updatePhase, deletePhase: Gestion phases
         * - deleteTask: Suppression de template (avec cleanup employee_tasks)
         */
        const AdminPanel = ({ 
            employees, setEmployees, 
            resources, setResources, 
            phaseTemplates, setPhaseTemplates, 
            taskTemplates, setTaskTemplates,
            supabase, useSupabase, 
            showNotification, uploadAvatar, onClose,
            selectedEmployee // Ajout de selectedEmployee en prop
        }) => {
            const [activeTab, setActiveTab] = useState('employees');
            
            // Helper function to save task field to Supabase - DEFINIE DANS AdminPanel
            const saveTaskField = async (taskId, field, value, dbFieldName = null) => {
                if (!useSupabase || !supabase) {
                    console.warn(' Supabase non disponible pour sauvegarder', field);
                    return false;
                }
                
                try {
                    //  FIX: dueDate n'existe pas en DB, ne jamais essayer de le sauvegarder
                    if (field === 'dueDate') {
                        console.error(' [AdminPanel] Tentative de sauvegarder dueDate qui n\'existe pas en DB. Utilisez dayOffset a la place.');
                        return false;
                    }
                    
                    const dbField = dbFieldName || (field === 'phaseId' ? 'phase_id' : 
                                                     field === 'dayOffset' ? 'day_offset' : 
                                                     field === 'startDate' ? 'start_date' :
                                                     field === 'endDate' ? 'end_date' :
                                                     field === 'assignedTo' ? 'assigned_to' : field);
                    
                    console.log(` [AdminPanel] Sauvegarde ${field} (${dbField}) pour tache ${taskId}:`, value);
                    
                    const { data, error } = await supabase
                        .from('task_templates')
                        .update({ [dbField]: value })
                        .eq('id', taskId)
                        .select();
                    
                    if (error) {
                        //  FIX: Gerer les erreurs de colonnes manquantes gracieusement
                        if (error.message && (error.message.includes('column') || error.message.includes('not found') || error.message.includes('schema cache'))) {
                            console.warn(` Colonne ${dbField} non trouvee dans task_templates. Migration SQL necessaire.`);
                            console.warn(`   Erreur complete:`, error);
                            showNotification(`Colonne ${dbField} manquante. Executez la migration 013_add_task_dates.sql dans Supabase.`, 'warning');
                            // Ne pas bloquer l'UI, retourner false mais continuer
                            return false;
                        }
                        console.error(` Erreur sauvegarde ${field}:`, error);
                        showNotification(`Erreur sauvegarde ${field}: ${error.message || error.details}`, 'error');
                        return false;
                    }
                    
                    if (data && data.length > 0) {
                        console.log(` [AdminPanel] ${field} sauvegarde avec succes pour tache ${taskId}`);
                        return true;
                    } else {
                        console.warn(` Aucune donnee retournee pour tache ${taskId}`);
                        return false;
                    }
                } catch (e) {
                    console.error(` Exception lors de la sauvegarde ${field}:`, e);
                    showNotification(`Erreur sauvegarde ${field}: ${e.message || e.details}`, 'error');
                    return false;
                }
            };
            const [newEmpName, setNewEmpName] = useState('');
            const [newEmpRole, setNewEmpRole] = useState('');
            const [newEmpEmail, setNewEmpEmail] = useState('');

            // --- Logic Employes ---
            const handleAddEmployee = async () => {
                const newId = (Math.max(...employees.map(e => e.id), 0) || 0) + 1;
                const newEmp = { 
                    id: newId, 
                    name: newEmpName || 'Nouvel Employe', 
                    role: newEmpRole || 'Poste', 
                    email: newEmpEmail, 
                    startDate: new Date('2026-01-01').toISOString().split('T')[0],
                    avatarUrl: null
                };
                setEmployees([...employees, newEmp]);
                setNewEmpName(''); setNewEmpRole(''); setNewEmpEmail('');
                
                if (useSupabase && supabase) {
                    const { error } = await supabase.from('employees').insert([{ name: newEmp.name, role: newEmp.role, email: newEmp.email, start_date: newEmp.startDate }]);
                    if (error) showNotification('Erreur DB', 'error');
                }
                showNotification('Employe ajoute', 'success');
            };

            const updateEmp = async (id, field, value) => {
                setEmployees(prev => prev.map(e => e.id === id ? { ...e, [field]: value } : e));
                if (useSupabase && supabase) {
                    try {
                        const col = field === 'startDate' ? 'start_date' : field === 'avatarUrl' ? 'avatar_url' : field;
                        const { error } = await supabase.from('employees').update({ [col]: value }).eq('id', id);
                        if (error) throw error;
                    } catch (e) {
                        console.error('Update Employee Error:', e);
                        showNotification('Erreur sauvegarde employe', 'error');
                    }
                }
            };

            const duplicateEmp = (emp) => {
                const newId = (Math.max(...employees.map(e => e.id), 0) || 0) + 1;
                const copy = { ...emp, id: newId, name: `${emp.name} (Copie)` };
                setEmployees([...employees, copy]);
                if (useSupabase && supabase) {
                     supabase.from('employees').insert([{ name: copy.name, role: copy.role, email: copy.email, start_date: copy.startDate }]);
                }
                showNotification('Employe duplique', 'success');
            };

            const handleDeleteEmployee = async (empId) => {
                if (!confirm('Voulez-vous vraiment supprimer cet employe ? Cette action est irreversible.')) return;
                
                // Optimistic: immediately remove from UI
                setEmployees(prev => prev.filter(e => e.id !== empId));

                if (useSupabase && supabase) {
                    try {
                        const { error: taskError } = await supabase.from('employee_tasks').delete().eq('employee_id', empId);
                        if (taskError) console.warn('Error clearing employee tasks:', taskError);

                        const { error } = await supabase.from('employees').delete().eq('id', empId);
                        if (error) throw error;
                        
                        showNotification('Employe supprime', 'success');
                    } catch (error) {
                        console.error('Delete Employee Error:', error);
                        // Re-fetch to restore state in case of error, or just warn
                        alert("Erreur lors de la suppression (voir console). Il est possible que des donnees liees empechent la suppression.");
                    }
                }
            };

            // --- Logic Resources ---
            const [newResName, setNewResName] = useState('');

            const handleAddResource = async () => {
                const newId = (Math.max(...resources.map(r => r.id), 0) || 0) + 1;
                const newRes = { id: newId, name: newResName || 'Ressource', role: 'Role', color: '#3B82F6', email: '', avatar: 'R' };
                
                setResources([...resources, newRes]);
                setNewResName('');

                if (useSupabase && supabase) {
                    try {
                        const { data, error } = await supabase.from('resources').insert([{
                            name: newRes.name,
                            role: newRes.role,
                            color: newRes.color,
                            email: newRes.email,
                            avatar_initials: newRes.avatar,
                            display_order: newId
                        }]).select();
                        if (error) throw error;
                        
                        // Update the local state with the actual ID from Supabase
                        if (data && data.length > 0) {
                            setResources(prev => prev.map(r => r.id === newId ? { ...r, id: data[0].id } : r));
                        }
                        showNotification('Ressource ajoutee', 'success');
                    } catch (e) {
                         console.error('Error adding resource:', e);
                         showNotification('Erreur ajout ressource', 'error');
                    }
                }
            };

            const updateRes = async (id, field, value) => {
                setResources(prev => prev.map(r => r.id === id ? { ...r, [field]: value } : r));
                
                if (useSupabase && supabase) {
                    try {
                        const dbField = field === 'avatar' ? 'avatar_initials' : field;
                        const { error } = await supabase.from('resources').update({ [dbField]: value }).eq('id', id);
                        if (error) throw error;
                    } catch (e) {
                        console.error('Error updating resource:', e);
                        showNotification('Erreur modification ressource', 'error');
                    }
                }
            };

            const handleDeleteResource = async (resId) => {
                if (!confirm('Voulez-vous vraiment supprimer cette ressource ?')) return;

                // Check dependencies (Tasks)
                const assignedTasks = taskTemplates.filter(t => t.assignedTo && t.assignedTo.includes(resId));
                if (assignedTasks.length > 0) {
                     if(!confirm(`Cette ressource est assignee a ${assignedTasks.length} modeles de taches. Voulez-vous continuer ? (Elle sera retiree de ces taches)`)) return;
                }

                setResources(prev => prev.filter(r => r.id !== resId));

                if (useSupabase && supabase) {
                    try {
                        const { error } = await supabase.from('resources').delete().eq('id', resId);
                        if (error) throw error;
                        showNotification('Ressource supprimee', 'success');
                    } catch (e) {
                        console.error('Error deleting resource:', e);
                        handleSupabaseError(e, 'Delete Resource');
                        alert("Impossible de supprimer cette ressource (probablement liee a des donnees existantes).");
                        window.location.reload();
                    }
                }
            };

            // --- Logic Phases ---
             const updatePhase = async (id, field, value) => {
                setPhaseTemplates(prev => prev.map(p => p.id === id ? { ...p, [field]: value } : p));
                if (useSupabase && supabase) {
                     const col = field === 'startOffset' ? 'start_offset' : field;
                     supabase.from('phases').update({ [col]: value }).eq('id', id);
                }
            };

            const handleAddPhase = async () => {
                const newId = (Math.max(...phaseTemplates.map(p => p.id), 0) || 0) + 1;
                const newPhase = {
                    id: newId,
                    name: `Nouvelle Phase ${newId}`,
                    description: 'Description de la phase',
                    duration: 5,
                    startOffset: 0,
                    color: '#' + Math.floor(Math.random()*16777215).toString(16),
                    order: newId
                };
                
                setPhaseTemplates([...phaseTemplates, newPhase]);
                
                if (useSupabase && supabase) {
                    const { error } = await supabase.from('phases').insert([{
                        name: newPhase.name,
                        description: newPhase.description,
                        duration: newPhase.duration,
                        start_offset: newPhase.startOffset,
                        color: newPhase.color,
                        display_order: newPhase.order
                    }]);
                    if (error) {
                        console.error('Error adding phase:', error);
                        showNotification('Erreur ajout phase', 'error');
                    }
                }
                showNotification('Phase ajoutee', 'success');
            };

            const handleDeletePhase = async (id) => {
                // Check for assigned tasks
                const assignedTasks = taskTemplates.filter(t => t.phaseId === id);
                if (assignedTasks.length > 0) {
                    alert(`Impossible de supprimer cette phase : ${assignedTasks.length} modele(s) de tache y sont assignes. Veuillez d'abord supprimer ou deplacer ces taches.`);
                    return;
                }

                if (!confirm('Etes-vous sur de vouloir supprimer cette phase ?')) return;

                setPhaseTemplates(prev => prev.filter(p => p.id !== id));

                if (useSupabase && supabase) {
                    const { error } = await supabase.from('phases').delete().eq('id', id);
                    if (error) {
                        console.error('Error deleting phase:', error);
                        showNotification('Erreur suppression phase', 'error');
                    }
                }
                showNotification('Phase supprimee', 'success');
            };

            // --- Logic Tasks ---
            const deleteTask = async (taskId) => {
                 if (!confirm('Voulez-vous vraiment supprimer ce modele de tache ?')) return;
                 // Optimistic
                 setTaskTemplates(prev => prev.filter(t => t.id !== taskId));
                 
                 if (useSupabase && supabase) {
                      const { error } = await supabase.from('task_templates').delete().eq('id', taskId);
                      if (error) {
                          console.error('Error deleting task template:', error);
                          showNotification('Erreur suppression tache', 'error');
                      } else {
                          showNotification('Tache supprimee', 'success');
                      }
                 }
            };

            // --- Logic Recipes (Templates) ---
            const [recipes, setRecipes] = useState(() => {
                try { return JSON.parse(localStorage.getItem('onboarding_recipes') || '[]'); } catch { return []; }
            });
            const [newRecipeName, setNewRecipeName] = useState('');

            const handleSaveRecipe = () => {
                if (!newRecipeName.trim()) return showNotification('Nom de recette requis', 'error');
                const newRecipe = {
                    id: Date.now(),
                    name: newRecipeName,
                    phases: phaseTemplates, 
                    tasks: taskTemplates,
                    timestamp: new Date().toISOString()
                };
                const updated = [...recipes, newRecipe];
                setRecipes(updated);
                localStorage.setItem('onboarding_recipes', JSON.stringify(updated));
                setNewRecipeName('');
                showNotification('Recette sauvegardee !', 'success');
            };

            const handleLoadRecipe = (recipe) => {
                if(!confirm(`Attention: Charger "${recipe.name}" va ecraser la configuration actuelle (Phases et Modeles de taches). Continuer ?`)) return;
                
                // Deep copy to avoid reference issues
                setPhaseTemplates(JSON.parse(JSON.stringify(recipe.phases)));
                setTaskTemplates(JSON.parse(JSON.stringify(recipe.tasks)));
                
                // If using supabase, this would need complex sync logic. For now, we rely on local state updates/localstorage.
                showNotification(`Configuration "${recipe.name}" chargee`, 'success');
            };

            const handleDeleteRecipe = (id) => {
                const updated = recipes.filter(r => r.id !== id);
                setRecipes(updated);
                localStorage.setItem('onboarding_recipes', JSON.stringify(updated));
                showNotification('Recette supprimee', 'success');
            };

            return (
                <div className="fixed inset-0 bg-gray-900/60 backdrop-blur-md z-[100] flex items-center justify-center p-4 animate-fade-in">
                    <div className="bg-white/95 backdrop-blur-xl rounded-2xl w-full max-w-5xl max-h-[90vh] overflow-hidden shadow-2xl flex flex-col border border-white/20 ring-1 ring-black/5">
                        <div className="px-6 py-4 border-b border-gray-100 flex justify-between items-center bg-purple-600 text-white shadow-md z-10 relative overflow-hidden">
                             {/* Decorative background element */}
                             <div className="absolute top-0 right-0 w-64 h-full bg-white/5 skew-x-12 transform translate-x-12 pointer-events-none"></div>
                             
                             <h2 className="text-xl font-bold flex items-center gap-3 relative z-10">
                                <span className="bg-white/20 p-2 rounded-lg backdrop-blur-sm"><Icons.Settings /></span> 
                                Administration
                             </h2>
                             <div className="flex gap-3 relative z-10">
                                <button onClick={onClose} className="p-2 hover:bg-white/20 rounded-full transition-colors ml-2 text-white/80 hover:text-white"><Icons.X /></button>
                             </div>
                        </div>
                        <div className="flex border-b border-gray-100 bg-white overflow-x-auto shadow-sm relative z-0">
                            {[
                                { id: 'employees', icon: <Icons.Users />, label: 'Profils Employes' },
                                { id: 'resources', icon: <Icons.User />, label: 'Ressources' },
                                { id: 'phases', icon: <Icons.Layers />, label: 'Phases' },
                                { id: 'tasks', icon: <Icons.List />, label: 'Modeles Taches' },
                                { id: 'recipes', icon: <Icons.Book />, label: 'Recettes' }
                            ].map(tab => (
                                <button key={tab.id} onClick={() => setActiveTab(tab.id)} className={`px-6 py-4 font-bold text-sm flex items-center gap-2 transition-all relative ${activeTab === tab.id ? 'text-purple-600 bg-purple-50/50' : 'text-gray-500 hover:text-gray-700 hover:bg-gray-50'}`}>
                                    {tab.icon} {tab.label}
                                    {activeTab === tab.id && <div className="absolute bottom-0 left-0 right-0 h-0.5 bg-purple-600 rounded-t-full mx-6" />}
                                </button>
                            ))}
                        </div>
                        <div className="flex-1 overflow-hidden p-6 bg-gray-50/50 flex flex-col">
                            {activeTab === 'recipes' && (
                                <div className="space-y-6">
                                    {/* Create Recipe */}
                                    <div className="bg-blue-50 p-6 rounded-xl border border-blue-100 flex flex-col gap-4">
                                        <div className="flex items-center gap-3">
                                            <div className="bg-blue-600 text-white p-2 rounded-lg"><Icons.Save /></div>
                                            <div>
                                                <h3 className="font-bold text-gray-800">Sauvegarder la configuration actuelle</h3>
                                                <p className="text-xs text-gray-600">Cree un "Snapshot" de vos Phases et Modeles de taches actuels pour le reutiliser plus tard.</p>
                                            </div>
                                        </div>
                                        <div className="flex gap-2">
                                            <input 
                                                className="flex-1 px-4 py-2 rounded-lg border focus:ring-2 focus:ring-blue-500 outline-none" 
                                                placeholder="Nom de la recette (ex: Onboarding Vente, Dev Senior...)" 
                                                value={newRecipeName}
                                                onChange={e => setNewRecipeName(e.target.value)}
                                            />
                                            <button onClick={handleSaveRecipe} className="bg-blue-600 hover:bg-blue-700 text-white px-6 py-2 rounded-lg font-bold transition-colors">Enregistrer</button>
                                        </div>
                                    </div>

                                    {/* List Recipes */}
                                    <div className="space-y-3">
                                        <h3 className="font-bold text-gray-700 ml-1">Recettes disponibles ({recipes.length})</h3>
                                        {recipes.length === 0 ? (
                                            <div className="text-center py-12 bg-white rounded-xl border border-dashed text-gray-400">
                                                Aucune recette enregistree. Creez-en une ci-dessus !
                                            </div>
                                        ) : (
                                            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                                {recipes.map(recipe => (
                                                    <div key={recipe.id} className="bg-white p-4 rounded-xl border shadow-sm hover:shadow-md transition-all group relative overflow-hidden">
                                                        <div className="flex justify-between items-start mb-2 relative z-10">
                                                            <div className="flex items-center gap-2">
                                                                <span className="w-8 h-8 flex items-center justify-center bg-gray-100 rounded-lg text-gray-500"><Icons.Book /></span>
                                                                <div>
                                                                    <h4 className="font-bold text-gray-800">{recipe.name}</h4>
                                                                    <p className="text-[10px] text-gray-400">{new Date(recipe.timestamp).toLocaleDateString()} - {recipe.tasks.length} taches, {recipe.phases.length} phases</p>
                                                                </div>
                                                            </div>
                                                            <button onClick={() => handleDeleteRecipe(recipe.id)} className="text-red-400 hover:text-red-600 p-1 opacity-0 group-hover:opacity-100 transition-opacity"><Icons.Trash /></button>
                                                        </div>
                                                        <div className="mt-4 flex gap-2 relative z-10">
                                                            <button onClick={() => handleLoadRecipe(recipe)} className="flex-1 bg-gray-50 hover:bg-blue-50 hover:text-blue-600 text-gray-600 py-2 rounded-lg text-sm font-bold border border-gray-200 hover:border-blue-200 transition-all flex items-center justify-center gap-2">
                                                                <Icons.Upload /> Charger cette config
                                                            </button>
                                                        </div>
                                                        <div className="absolute -right-4 -bottom-4 w-24 h-24 bg-gradient-to-br from-gray-50 to-gray-100 rounded-full opacity-50 z-0"></div>
                                                    </div>
                                                ))}
                                            </div>
                                        )}
                                    </div>
                                </div>
                            )}

                            {activeTab === 'employees' && (
                                <div className="space-y-6">
                                    <div className="bg-white p-4 rounded-xl border shadow-sm flex gap-2 items-end">
                                        <div className="flex-1 grid grid-cols-3 gap-2">
                                            <div className="space-y-1"><label className="text-xs font-bold text-gray-500">Nom</label><input className="w-full p-2 border rounded" value={newEmpName} onChange={e => setNewEmpName(e.target.value)} placeholder="Ex: Julie Gagnon" /></div>
                                            <div className="space-y-1"><label className="text-xs font-bold text-gray-500">Role</label><input className="w-full p-2 border rounded" value={newEmpRole} onChange={e => setNewEmpRole(e.target.value)} placeholder="Ex: Adjointe" /></div>
                                            <div className="space-y-1"><label className="text-xs font-bold text-gray-500">Email</label><input className="w-full p-2 border rounded" value={newEmpEmail} onChange={e => setNewEmpEmail(e.target.value)} placeholder="julie@gob.com" /></div>
                                        </div>
                                        <button onClick={handleAddEmployee} className="px-4 py-2 bg-blue-600 text-white rounded-lg font-bold hover:bg-blue-700 h-[42px]"><Icons.Plus /> Ajouter</button>
                                    </div>
                                    <div className="grid grid-cols-1 gap-3">
                                        {employees.map(emp => (
                                            <div key={emp.id} className="bg-white p-3 rounded-xl border flex items-center gap-3 shadow-sm hover:shadow-md transition-shadow">
                                                <div className="relative group w-12 h-12">
                                                    <img src={emp.avatarUrl || `https://ui-avatars.com/api/?name=${emp.name}&background=random`} className="w-12 h-12 rounded-full object-cover border" />
                                                    <label className="absolute inset-0 bg-black/50 rounded-full flex items-center justify-center text-white text-[8px] opacity-0 group-hover:opacity-100 cursor-pointer pt-3">
                                                        PHOTO
                                                        <input type="file" className="hidden" accept="image/*" onChange={async(e) => { if(e.target.files[0]) { const url = await uploadAvatar(e.target.files[0]); if(url) updateEmp(emp.id, 'avatarUrl', url); } }} />
                                                    </label>
                                                </div>
                                                <div className="flex-1 grid grid-cols-2 gap-2">
                                                    <input className="font-bold border-b border-transparent hover:border-gray-200 focus:border-blue-500 outline-none" value={emp.name} onChange={e => updateEmp(emp.id, 'name', e.target.value)} />
                                                    <input className="text-sm text-gray-500 border-b border-transparent hover:border-gray-200 focus:border-blue-500 outline-none" value={emp.role} onChange={e => updateEmp(emp.id, 'role', e.target.value)} />
                                                </div>
                                                <div className="flex items-center gap-2">
                                                     <div className="flex items-center gap-1">
                                                         <span className="text-[10px] font-bold text-gray-400 uppercase whitespace-nowrap">Debut :</span>
                                                         <input 
                                                             type="date" 
                                                             className="w-32 text-xs border rounded px-1 py-1" 
                                                             value={(() => {
                                                                 const date = emp.startDate || '2026-01-01';
                                                                 const minDate = new Date('2026-01-01');
                                                                 const empDate = new Date(date);
                                                                 return empDate < minDate ? '2026-01-01' : date;
                                                             })()} 
                                                             min="2026-01-01" 
                                                             onChange={e => {
                                                                 const newValue = e.target.value;
                                                                 // Forcer la date a etre au minimum 2026-01-01
                                                                 const finalValue = newValue < '2026-01-01' ? '2026-01-01' : newValue;
                                                                 updateEmp(emp.id, 'startDate', finalValue);
                                                             }} 
                                                             title="Date de debut d'emploi (minimum 2026-01-01)" 
                                                         />
                                                     </div>
                                                     <button onClick={() => duplicateEmp(emp)} className="p-1.5 text-blue-500 hover:bg-blue-50 rounded" title="Dupliquer"><Icons.Copy /></button>
                                                     <button onClick={(e) => { e.stopPropagation(); handleDeleteEmployee(emp.id); }} className="p-1.5 text-red-500 hover:bg-red-50 rounded transition-colors" title="Supprimer l'employe"><Icons.Trash /></button>
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            )}
                            {activeTab === 'resources' && (
                                <div className="space-y-6">
                                    <div className="bg-white p-4 rounded-xl border shadow-sm flex gap-2">
                                        <input className="flex-1 p-2 border rounded" placeholder="Nom de la ressource" value={newResName} onChange={e => setNewResName(e.target.value)} />
                                        <button onClick={handleAddResource} className="px-4 py-2 bg-blue-600 text-white rounded-lg font-bold"><Icons.Plus /> Ajouter</button>
                                    </div>
                                    <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
                                        {resources.map(res => (
                                            <div key={res.id} className="bg-white p-3 rounded-xl border flex items-center gap-3">
                                                <div className="w-10 h-10 rounded-full flex items-center justify-center text-white text-xs font-bold border-2 border-white shadow-sm ring-1 ring-gray-100" style={{ backgroundColor: res.color }}>
                                                    {res.name.charAt(0)}
                                                </div>
                                                <div className="flex-1 space-y-1">
                                                    <input className="w-full font-bold text-sm border-b border-transparent focus:border-blue-500 outline-none" value={res.name} onChange={e => updateRes(res.id, 'name', e.target.value)} />
                                                    <input className="w-full text-xs text-gray-500 border-b border-transparent focus:border-blue-500 outline-none" value={res.role} onChange={e => updateRes(res.id, 'role', e.target.value)} />
                                                </div>
                                                <input type="color" className="w-8 h-8 rounded cursor-pointer border-0 p-0" value={res.color} onChange={e => updateRes(res.id, 'color', e.target.value)} />
                                                <button onClick={(e) => { e.stopPropagation(); handleDeleteResource(res.id); }} className="text-red-400 hover:text-red-600 transition-colors" title="Supprimer la ressource"><Icons.Trash /></button>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            )}
                             {activeTab === 'phases' && (
                                <div className="space-y-4">
                                    <div className="bg-white p-4 rounded-xl border shadow-sm flex justify-between items-center">
                                        <h3 className="font-bold text-gray-700">Gestion des Phases</h3>
                                        <button onClick={handleAddPhase} className="px-4 py-2 bg-blue-600 text-white rounded-lg font-bold hover:bg-blue-700 gap-2 flex items-center">
                                            <Icons.Plus /> Ajouter une Phase
                                        </button>
                                    </div>
                                    <div className="grid gap-4">
                                        {phaseTemplates.map(phase => (
                                            <div key={phase.id} className="bg-white p-4 rounded-xl border-l-4 shadow-sm relative group" style={{ borderLeftColor: phase.color }}>
                                                <div className="flex items-center gap-3 mb-2">
                                                    <input type="color" value={phase.color} onChange={e => updatePhase(phase.id, 'color', e.target.value)} className="w-6 h-6 rounded cursor-pointer border-0" />
                                                    <input className="flex-1 font-bold text-lg border-b border-transparent focus:border-blue-500 outline-none" value={phase.name} onChange={e => updatePhase(phase.id, 'name', e.target.value)} />
                                                    <button 
                                                        onClick={() => handleDeletePhase(phase.id)} 
                                                        className="p-2 text-gray-400 hover:text-red-500 hover:bg-red-50 rounded-lg transition-all opacity-0 group-hover:opacity-100"
                                                        title="Supprimer la phase"
                                                    >
                                                        <Icons.Trash />
                                                    </button>
                                                </div>
                                                <div className="grid grid-cols-2 gap-4 text-sm pl-9">
                                                    {/* Dates de debut et fin avec calendriers */}
                                                    <div className="col-span-2 mb-2">
                                                        <div className="flex items-center gap-3 text-xs text-gray-600 mb-1">
                                                            <span className="font-bold uppercase">Periode :</span>
                                                            <div className="flex items-center gap-2">
                                                                <div className="flex items-center gap-1">
                                                                    <span className="text-[10px] font-bold text-gray-400 uppercase">Debut :</span>
                                                                    <DatePicker
                                                                        value={(() => {
                                                                            const emp = selectedEmployee || employees[0];
                                                                            const empStart = TaskManager.ensureMinDate2026(emp?.startDate);
                                                                            const phaseStart = new Date(empStart.getTime() + (phase.startOffset || 0) * 86400000);
                                                                            return phaseStart.toISOString().split('T')[0];
                                                                        })()}
                                                                        onChange={(dateStr) => {
                                                                            const emp = selectedEmployee || employees[0];
                                                                            const empStart = TaskManager.ensureMinDate2026(emp?.startDate);
                                                                            const newStart = new Date(dateStr);
                                                                            const diffDays = Math.round((newStart.getTime() - empStart.getTime()) / (1000 * 60 * 60 * 24));
                                                                            updatePhase(phase.id, 'startOffset', diffDays);
                                                                        }}
                                                                        placeholder="Date debut"
                                                                        className="bg-white border border-gray-300 rounded-lg px-2 py-1 text-xs hover:border-blue-500 focus:border-blue-500"
                                                                        min="2026-01-01"
                                                                        showIcon={true}
                                                                    />
                                                                </div>
                                                                <span className="text-gray-400">-></span>
                                                                <div className="flex items-center gap-1">
                                                                    <span className="text-[10px] font-bold text-gray-400 uppercase">Fin :</span>
                                                                    <DatePicker
                                                                        value={(() => {
                                                                            const emp = selectedEmployee || employees[0];
                                                                            const empStart = TaskManager.ensureMinDate2026(emp?.startDate);
                                                                            const phaseStart = new Date(empStart.getTime() + (phase.startOffset || 0) * 86400000);
                                                                            const phaseEnd = new Date(phaseStart.getTime() + (phase.duration || 1) * 86400000);
                                                                            return phaseEnd.toISOString().split('T')[0];
                                                                        })()}
                                                                        onChange={(dateStr) => {
                                                                            const emp = selectedEmployee || employees[0];
                                                                            const empStart = TaskManager.ensureMinDate2026(emp?.startDate);
                                                                            const phaseStart = new Date(empStart.getTime() + (phase.startOffset || 0) * 86400000);
                                                                            const newEnd = new Date(dateStr);
                                                                            const duration = Math.round((newEnd.getTime() - phaseStart.getTime()) / (1000 * 60 * 60 * 24)) + 1;
                                                                            if (duration > 0) {
                                                                                updatePhase(phase.id, 'duration', duration);
                                                                            }
                                                                        }}
                                                                        placeholder="Date fin"
                                                                        className="bg-white border border-gray-300 rounded-lg px-2 py-1 text-xs hover:border-blue-500 focus:border-blue-500"
                                                                        min={(() => {
                                                                            const emp = selectedEmployee || employees[0];
                                                                            const empStart = TaskManager.ensureMinDate2026(emp?.startDate);
                                                                            const phaseStart = new Date(empStart.getTime() + (phase.startOffset || 0) * 86400000);
                                                                            return phaseStart.toISOString().split('T')[0];
                                                                        })()}
                                                                        showIcon={true}
                                                                    />
                                                                </div>
                                                            </div>
                                                        </div>
                                                    </div>
                                                    <div>
                                                        <label className="text-xs text-gray-500 font-bold uppercase">Duree (jours)</label>
                                                        <input type="number" className="w-full p-1 border rounded" value={phase.duration} onChange={e => updatePhase(phase.id, 'duration', parseInt(e.target.value))} />
                                                    </div>
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            )}
                            {activeTab === 'tasks' && (
                                <div className="flex flex-col flex-1 min-h-0">
                                     {/* Add Task Form - FIXE EN HAUT */}
                                    <div className="bg-white p-4 rounded-xl border shadow-sm flex flex-col gap-4 flex-shrink-0 mb-4">
                                         <div className="grid grid-cols-1 md:grid-cols-12 gap-3">
                                            <input id="newTaskTitle" className="md:col-span-4 p-2.5 border border-gray-200 rounded-lg text-sm bg-gray-50/50 focus:bg-white outline-none focus:border-purple-500 transition-all font-medium placeholder-gray-400" placeholder="Titre de la tache" />
                                            <input id="newTaskDesc" className="md:col-span-3 p-2.5 border border-gray-200 rounded-lg text-sm bg-gray-50/50 focus:bg-white outline-none focus:border-purple-500 transition-all placeholder-gray-400" placeholder="Description" />
                                            
                                            <div className="md:col-span-3">
                                                <select id="newTaskPhase" className="w-full p-2.5 border border-gray-200 rounded-lg text-sm bg-white outline-none focus:border-purple-500 transition-all font-medium text-gray-700">
                                                    {phaseTemplates.map(p => <option key={p.id} value={p.id}>{p.name}</option>)}
                                                </select>
                                            </div>

                                            <button onClick={() => {
                                                const title = document.getElementById('newTaskTitle').value;
                                                const desc = document.getElementById('newTaskDesc').value || '';
                                                const phaseId = parseInt(document.getElementById('newTaskPhase').value);
                                                const startDate = document.getElementById('newTaskStartDate').value || '2026-01-01';
                                                const endDate = document.getElementById('newTaskEndDate').value || startDate;
                                                const priority = document.getElementById('newTaskPriority').value;
                                                const category = document.getElementById('newTaskCategory').value;
                                                
                                                if(!title) return alert('Titre requis');
                                                
                                                const newId = (Math.max(...taskTemplates.map(t => t.id), 0) || 0) + 1;
                                                const newTask = { 
                                                    id: newId, 
                                                    title, 
                                                    description: desc,
                                                    phaseId, 
                                                    startDate,
                                                    endDate,
                                                    priority,
                                                    category, 
                                                    assignedTo: [] 
                                                };
                                                setTaskTemplates([...taskTemplates, newTask]);
                                                
                                                if(useSupabase && supabase) {
                                                    //  FIX: Inserer avec gestion d'erreur pour colonnes manquantes
                                                    supabase.from('task_templates').insert([{ 
                                                        title, 
                                                        description: desc,
                                                        phase_id: phaseId, 
                                                        start_date: startDate,
                                                        end_date: endDate,
                                                        day_offset: 0, // Retrocompatibilite
                                                        category,
                                                        priority // Ensure DB column exists or ignore
                                                    }]).then(({error}) => {
                                                        if (error) {
                                                            if (error.message && (error.message.includes('column') || error.message.includes('not found') || error.message.includes('schema cache'))) {
                                                                console.warn(' Colonnes start_date/end_date manquantes. Migration SQL necessaire.');
                                                                showNotification('Migration SQL necessaire pour start_date/end_date. Voir 013_add_task_dates.sql', 'warning');
                                                            } else {
                                                                console.error('Erreur insertion tache:', error);
                                                            }
                                                        }
                                                    });
                                                }
                                                document.getElementById('newTaskTitle').value = '';
                                                document.getElementById('newTaskDesc').value = '';
                                                showNotification('Tache ajoutee', 'success');
                                            }} className="md:col-span-2 w-full py-2.5 bg-purple-600 hover:bg-purple-700 text-white rounded-lg font-bold shadow-md hover:shadow-lg transition-all active:scale-95 flex items-center justify-center gap-2">
                                                <Icons.Plus className="w-4 h-4" /> Ajouter
                                            </button>
                                         </div>

                                         <div className="grid grid-cols-1 md:grid-cols-12 gap-3 pt-2 border-t border-gray-100">
                                             <div className="md:col-span-3">
                                                 <select id="newTaskPriority" className="w-full p-2 border border-gray-200 rounded-lg text-sm outline-none focus:border-purple-500 bg-white text-gray-600">
                                                    <option value="medium">Moyenne</option>
                                                    <option value="high">Haute</option>
                                                    <option value="low">Basse</option>
                                                </select>
                                             </div>
                                             <div className="md:col-span-3">
                                                 <select id="newTaskCategory" className="w-full p-2 border border-gray-200 rounded-lg text-sm outline-none focus:border-purple-500 bg-white text-gray-600">
                                                    <option value="administratif">Administratif</option>
                                                    <option value="technique">Technique</option>
                                                    <option value="formation">Formation</option>
                                                    <option value="autre">Autre</option>
                                                </select>
                                             </div>
                                              <div className="md:col-span-2 flex items-center gap-2">
                                                <span className="text-gray-500 text-sm font-bold">J+</span>
                                                <div className="flex items-center gap-2">
                                                    <input type="date" id="newTaskStartDate" className="w-full p-2 border border-gray-200 rounded-lg text-sm outline-none focus:border-purple-500" min="2026-01-01" max="2026-03-31" defaultValue="2026-01-01" />
                                                    <span className="text-gray-400">-></span>
                                                    <input type="date" id="newTaskEndDate" className="w-full p-2 border border-gray-200 rounded-lg text-sm outline-none focus:border-purple-500" min="2026-01-01" max="2026-03-31" defaultValue="2026-01-01" />
                                                </div>
                                             </div>
                                         </div>
                                    </div>

                                    {/* Task List Grouped by Phase - SCROLLABLE */}
                                    <div className="flex-1 overflow-y-auto space-y-8 pb-12 pr-2 -mr-2">
                                        {phaseTemplates.sort((a,b) => (a.displayOrder || 0) - (b.displayOrder || 0)).map(phase => (
                                            <div key={phase.id} className="bg-blue-50/30 rounded-xl overflow-hidden border border-blue-100/50">
                                                {/* Phase Header */}
                                                <div className="px-5 py-3 bg-blue-50 border-b border-blue-100 flex items-center gap-3">
                                                    <div className="w-1.5 h-6 rounded-full" style={{backgroundColor: phase.color || '#3B82F6'}}></div>
                                                    <h3 className="font-bold text-gray-800 text-lg flex-1">{phase.name}</h3>
                                                    <span className="text-xs font-bold text-blue-600 bg-blue-100 px-2 py-1 rounded-full uppercase tracking-wider">{taskTemplates.filter(t => t.phaseId === phase.id).length} taches</span>
                                                </div>

                                                <div className="p-3 space-y-2">
                                                    {taskTemplates.filter(t => t.phaseId === phase.id).map(task => (
                                                        <div key={task.id} className="group bg-white p-4 rounded-xl border border-gray-100 shadow-sm hover:shadow-md hover:border-blue-200 transition-all flex flex-col md:flex-row md:items-center gap-4">
                                                            {/* Main Info */}
                                                            <div className="flex-1 min-w-[250px] flex flex-col gap-1">
                                                                <input 
                                                                    className="font-bold text-gray-800 bg-transparent border-none p-0 outline-none focus:ring-0 text-base"
                                                                    value={task.title}
                                                                    onChange={(e) => {
                                                                        const val = e.target.value;
                                                                        setTaskTemplates(prev => prev.map(t => t.id === task.id ? { ...t, title: val } : t));
                                                                    }}
                                                                    onBlur={async (e) => {
                                                                        const val = e.target.value;
                                                                        await saveTaskField(task.id, 'title', val);
                                                                    }}
                                                                />
                                                                <input 
                                                                    className="text-xs text-gray-500 bg-transparent border-none p-0 outline-none focus:ring-0 placeholder-gray-300"
                                                                    value={task.description || ''}
                                                                    placeholder="Aucune description..."
                                                                    onChange={(e) => {
                                                                         const val = e.target.value;
                                                                         setTaskTemplates(prev => prev.map(t => t.id === task.id ? { ...t, description: val } : t));
                                                                    }}
                                                                    onBlur={async (e) => {
                                                                        const val = e.target.value;
                                                                        await saveTaskField(task.id, 'description', val);
                                                                    }}
                                                                />
                                                            </div>

                                                            {/* Dropdowns & Options */}
                                                            <div className="flex items-center gap-3 flex-wrap">
                                                                {/* Priority */}
                                                                <div className="relative">
                                                                    <select 
                                                                        value={task.priority || 'medium'} 
                                                                        onChange={async (e) => {
                                                                            const val = e.target.value;
                                                                            setTaskTemplates(prev => prev.map(t => t.id === task.id ? { ...t, priority: val } : t));
                                                                            await saveTaskField(task.id, 'priority', val);
                                                                        }}
                                                                        className={`appearance-none pl-3 pr-8 py-1.5 rounded-lg text-xs font-bold uppercase tracking-wider border outline-none cursor-pointer transition-colors ${
                                                                            task.priority === 'high' ? 'bg-red-50 text-red-600 border-red-100 hover:bg-red-100' : 
                                                                            task.priority === 'low' ? 'bg-blue-50 text-blue-600 border-blue-100 hover:bg-blue-100' : 
                                                                            'bg-orange-50 text-orange-600 border-orange-100 hover:bg-orange-100'
                                                                        }`}
                                                                    >
                                                                        <option value="high">Haute</option>
                                                                        <option value="medium">Moyenne</option>
                                                                        <option value="low">Basse</option>
                                                                    </select>
                                                                    <div className="absolute right-2 top-1/2 -translate-y-1/2 pointer-events-none opacity-50"><Icons.ChevronDown className="w-3 h-3" /></div>
                                                                </div>

                                                                {/* Dates de debut et fin - 1er trimestre 2026 */}
                                                                <div className="flex items-center gap-2 flex-wrap">
                                                                    <div className="flex items-center gap-1">
                                                                        <span className="text-[10px] font-bold text-gray-400 uppercase">Debut :</span>
                                                                        <DatePicker
                                                                            value={(() => {
                                                                                // Forcer la date dans Q1 2026 si elle est en dehors
                                                                                const currentDate = task.startDate || '2026-01-01';
                                                                                const validDate = TaskManager.ensureQ1_2026(currentDate);
                                                                                return validDate.toISOString().split('T')[0];
                                                                            })()}
                                                                            onChange={(dateStr) => {
                                                                                // Forcer la date dans Q1 2026
                                                                                const validDate = TaskManager.ensureQ1_2026(dateStr);
                                                                                const validDateStr = validDate.toISOString().split('T')[0];
                                                                                setTaskTemplates(prev => prev.map(t => t.id === task.id ? { ...t, startDate: validDateStr } : t));
                                                                                saveTaskField(task.id, 'startDate', validDateStr);
                                                                            }}
                                                                            placeholder="Date debut"
                                                                            className="px-2 py-1.5 rounded-lg border border-gray-200 bg-white text-xs"
                                                                            min="2026-01-01"
                                                                            max="2026-03-31"
                                                                            showIcon={true}
                                                                        />
                                                                    </div>
                                                                    <span className="text-gray-400">-></span>
                                                                    <div className="flex items-center gap-1">
                                                                        <span className="text-[10px] font-bold text-gray-400 uppercase">Fin :</span>
                                                                        <DatePicker
                                                                            value={(() => {
                                                                                // Forcer la date dans Q1 2026 si elle est en dehors
                                                                                const currentDate = task.endDate || task.startDate || '2026-01-01';
                                                                                const validDate = TaskManager.ensureQ1_2026(currentDate);
                                                                                return validDate.toISOString().split('T')[0];
                                                                            })()}
                                                                            onChange={(dateStr) => {
                                                                                // Forcer la date dans Q1 2026
                                                                                const validDate = TaskManager.ensureQ1_2026(dateStr);
                                                                                const validDateStr = validDate.toISOString().split('T')[0];
                                                                                // S'assurer que endDate >= startDate
                                                                                const taskStartDate = task.startDate || '2026-01-01';
                                                                                const finalDate = validDate >= new Date(taskStartDate) ? validDateStr : taskStartDate;
                                                                                setTaskTemplates(prev => prev.map(t => t.id === task.id ? { ...t, endDate: finalDate } : t));
                                                                                saveTaskField(task.id, 'endDate', finalDate);
                                                                            }}
                                                                            placeholder="Date fin"
                                                                            className="px-2 py-1.5 rounded-lg border border-gray-200 bg-white text-xs"
                                                                            min={task.startDate || '2026-01-01'}
                                                                            max="2026-03-31"
                                                                            showIcon={true}
                                                                        />
                                                                    </div>
                                                                </div>
                                                            </div>

                                                            {/* Resource Assignments */}
                                                            <div className="flex-1 flex flex-wrap gap-1 justify-end items-center px-4 md:border-l md:border-r border-gray-100 md:mx-2 min-w-[200px]">
                                                                {resources.map(res => {
                                                                    const isAssigned = (task.assignedTo || []).includes(res.id);
                                                                    return (
                                                                        <button 
                                                                            key={res.id}
                                                                            onClick={async () => {
                                                                                const current = task.assignedTo || [];
                                                                                const updated = current.includes(res.id) 
                                                                                    ? current.filter(id => id !== res.id)
                                                                                    : [...current, res.id];
                                                                                
                                                                                setTaskTemplates(prev => prev.map(t => t.id === task.id ? { ...t, assignedTo: updated } : t));
                                                                                
                                                                                await saveTaskField(task.id, 'assignedTo', updated);
                                                                            }}
                                                                            className={`px-2 py-1 rounded-md text-[10px] font-bold transition-all border shadow-sm ${
                                                                                isAssigned 
                                                                                ? 'bg-gradient-to-r from-purple-500 to-indigo-600 text-white border-transparent' 
                                                                                : 'bg-white text-gray-400 border-gray-200 hover:border-purple-300 hover:text-purple-600'
                                                                            }`}
                                                                            title={isAssigned ? `Assigne a ${res.name}` : `Assigner a ${res.name}`}
                                                                        >
                                                                            {res.name}
                                                                        </button>
                                                                    );
                                                                })}
                                                            </div>

                                                            {/* Actions */}
                                                            <button 
                                                                onClick={() => deleteTask(task.id)} 
                                                                className="w-8 h-8 flex items-center justify-center text-gray-300 hover:text-red-500 hover:bg-red-50 rounded-full transition-all md:opacity-0 group-hover:opacity-100"
                                                                title="Supprimer la tache"
                                                            >
                                                                <Icons.Trash className="w-4 h-4" />
                                                            </button>
                                                        </div>
                                                    ))}
                                                </div>
                                            </div>
                                        ))}

                                        {/* Empty State */}
                                        {taskTemplates.length === 0 && (
                                            <div className="text-center py-12 text-gray-400 bg-gray-50/50 rounded-xl border border-dashed text-sm">
                                                Aucune tache configuree. Commencez par en ajouter une ci-dessus !
                                            </div>
                                        )}
                                    </div>
                                </div>
                            )}
                        </div>
                    </div>
                </div>
            );
        };

        // Composant principal
        const OnboardingPlatform = () => {
             // Etats principaux
            const [employees, setEmployees] = useState(defaultEmployees);
            const [selectedEmployeeId, setSelectedEmployeeId] = useState(1);
            const [resources, setResources] = useState(defaultResources);
            const [phaseTemplates, setPhaseTemplates] = useState(defaultPhases);
            const [taskTemplates, setTaskTemplates] = useState(defaultTaskTemplates);
            const [employeeTasks, setEmployeeTasks] = useState({});
            
            const [isLoading, setIsLoading] = useState(false);
            const [showAdmin, setShowAdmin] = useState(false);
            const [isAuthenticated, setIsAuthenticated] = useState(false);
            const [viewMode, setViewMode] = useState('list');
            const [showEmailPreview, setShowEmailPreview] = useState(false);
            const [emailPreviewContent, setEmailPreviewContent] = useState('');
            const [searchTerm, setSearchTerm] = useState('');
            const [filterStatus, setFilterStatus] = useState('all');
            const [showUrgent, setShowUrgent] = useState(false);
            const [saveIndicator, setSaveIndicator] = useState({ visible: false, message: '' });
            const [showEmailPrompt, setShowEmailPrompt] = useState(false);
            const [emailPromptCallback, setEmailPromptCallback] = useState(null);
            const [resourcePanelTaskId, setResourcePanelTaskId] = useState(null); // State global pour panneau ressources

            const triggerSaveIndicator = (msg = 'Sauvegarde...') => {
                setSaveIndicator({ visible: true, message: msg });
                setTimeout(() => setSaveIndicator({ visible: false, message: '' }), 2000);
            };

            // ... (uploadAvatar omitted)

            // Fonction d'upload d'avatar (Supabase Storage)
            const uploadAvatar = async (file) => {
                if (!supabase || !useSupabase) {
                    alert("Supabase non configure pour l'upload");
                    return null;
                }
                const fileExt = file.name.split('.').pop();
                const fileName = `${Math.random()}.${fileExt}`;
                const filePath = `${fileName}`;

                try {
                    const { error: uploadError } = await supabase.storage.from('avatars').upload(filePath, file);
                    if (uploadError) throw uploadError;

                    const { data } = supabase.storage.from('avatars').getPublicUrl(filePath);
                    return data.publicUrl;
                } catch (error) {
                    console.error('Erreur upload:', error);
                    showNotification('Erreur upload image', 'error');
                    return null;
                }
            };

            /**
             * Recharge les task_templates depuis Supabase
             * Utilisee apres un conflit ou pour synchroniser l'etat local avec la DB
             * @returns {Promise<void>}
             */
            const reloadTaskTemplates = async () => {
                if (!useSupabase || !supabase) {
                    console.warn(' Supabase non disponible pour recharger les taches');
                    return;
                }
                try {
                    console.log(' Rechargement des task templates depuis Supabase...');
                    const { data, error } = await supabase
                        .from('task_templates')
                        .select('*')
                        .order('id', { ascending: true });
                    
                    if (error) {
                        console.error(' Erreur Supabase lors du rechargement:', error);
                        showNotification(`Erreur rechargement: ${error.message || 'Erreur inconnue'}`, 'error');
                        return;
                    }
                    
                    if (!data || data.length === 0) {
                        console.warn(' Aucune tache trouvee dans la base de donnees');
                        setTaskTemplates([]);
                        return;
                    }
                    
                    const mappedTasks = data.map(DataMapper.taskTemplateToReact);
                    setTaskTemplates(mappedTasks);
                    console.log(` ${mappedTasks.length} taches rechargees depuis la DB.`);
                } catch (error) {
                    console.error(" Exception lors du rechargement des taches:", error);
                    showNotification(`Erreur rechargement: ${error.message || 'Erreur inconnue'}`, 'error');
                }
            };

            /**
             * Chargement initial des donnees depuis Supabase
             * ------------------------------------------------
             * OPTIMISATION: Toutes les requetes sont executees en parallele avec Promise.all
             * Reduit le temps de chargement de ~800ms a ~200ms
             * 
             * TABLES CHARGEES:
             * - employees: Liste des employes
             * - resources: Contacts cles (responsables)
             * - phases: Phases d'integration
             * - task_templates: Templates de taches
             * - employee_tasks: Statuts des taches par employe
             * 
             *   Ne s'execute qu'une fois au montage (dependances vides [])
             */
            useEffect(() => {
                const fetchData = async () => {
                    if (!useSupabase || !supabase) return;
                    
                    setIsLoading(true);
                    const startTime = performance.now();
                    try {
                        // EXECUTION EN PARALLELE - Reduit le temps de chargement de ~800ms a ~200ms
                        const [empResult, resResult, phaseResult, taskResult, empTaskResult] = await Promise.all([
                            supabase.from('employees').select('*'),
                            supabase.from('resources').select('*').order('display_order'),
                            supabase.from('phases').select('*').order('display_order'),
                            supabase.from('task_templates').select('*'),
                            supabase.from('employee_tasks').select('*')
                        ]);

                        // Traitement des resultats avec DataMapper (OPTIMISE)
                        if (empResult.data) {
                            console.log(` ${empResult.data.length} employes recuperes.`);
                            setEmployees(empResult.data.map(DataMapper.employeeToReact));
                        } else if (empResult.error) {
                            console.warn('Fallback V1 table', empResult.error);
                        }

                        if (resResult.data) {
                            setResources(resResult.data.map(DataMapper.resourceToReact));
                        }

                        if (phaseResult.data) {
                            setPhaseTemplates(phaseResult.data.map(DataMapper.phaseToReact));
                        }

                        if (taskResult.data) {
                            setTaskTemplates(taskResult.data.map(DataMapper.taskTemplateToReact));
                        }

                        if (empTaskResult.data) {
                            const tasksMap = {};
                            empTaskResult.data.forEach(et => {
                                if (!tasksMap[et.employee_id]) tasksMap[et.employee_id] = {};
                                tasksMap[et.employee_id][et.template_id] = et.status;
                            });
                            setEmployeeTasks(tasksMap);
                        }

                        const loadTime = performance.now() - startTime;
                        console.log(` Donnees chargees en ${Math.round(loadTime)}ms (parallele)`);
                    } catch (error) {
                        console.error("Erreur chargement Supabase:", error);
                    } finally {
                        setIsLoading(false);
                    }
                };

                fetchData();
            }, []);

            /**
             * REAL-TIME SUBSCRIPTIONS - Synchronisation temps reel
             * -----------------------------------------------------
             * Ecoute les changements dans Supabase pour synchroniser automatiquement
             * l'interface entre tous les utilisateurs connectes.
             * 
             * OPTIMISATION: Demarre APRES le chargement initial (300ms de delai)
             * pour ne pas ralentir le rendu initial.
             * 
             * SUBSCRIPTIONS:
             * - employees: Ajout/modification/suppression d'employes
             * - employee_tasks: Changements de statut des taches
             * - resources: Ajout/modification de responsables
             * 
             * CLEANUP: Les subscriptions sont automatiquement nettoyees au demontage
             * 
             *   CRITIQUE: Ne pas demarrer si isLoading === true
             *   Les channels sont stockes dans window._realtimeChannels pour cleanup
             */
            useEffect(() => {
                if (!useSupabase || !supabase || isLoading) return; // Attendre la fin du chargement
                
                // Petit delai pour laisser le rendu initial se terminer
                const timeoutId = setTimeout(() => {
                    console.log(' Setting up real-time subscriptions...');
                    
                    // Helper to map employee data from DB format
                    const mapEmployee = (e) => ({
                        ...e,
                        avatarUrl: e.avatar_url || (e.name?.includes('Caroline') ? '/images/caroline_avatar.jpg' : null),
                        startDate: e.start_date || '2026-01-01',
                    });

                    // Subscribe to employees table changes
                    const employeesChannel = supabase
                        .channel('realtime-employees')
                        .on('postgres_changes', 
                            { event: '*', schema: 'public', table: 'employees' },
                            (payload) => {
                                console.log(' Real-time employee change:', payload.eventType);
                                if (payload.eventType === 'INSERT') {
                                    setEmployees(prev => [...prev, mapEmployee(payload.new)]);
                                    showNotification('Nouvel employe ajoute', 'success');
                                } else if (payload.eventType === 'UPDATE') {
                                    setEmployees(prev => prev.map(e => 
                                        e.id === payload.new.id ? mapEmployee(payload.new) : e
                                    ));
                                } else if (payload.eventType === 'DELETE') {
                                    setEmployees(prev => prev.filter(e => e.id !== payload.old.id));
                                }
                            }
                        )
                        .subscribe((status) => {
                            console.log(' Employees subscription:', status);
                        });

                    // Subscribe to employee_tasks table changes
                    const tasksChannel = supabase
                        .channel('realtime-tasks')
                        .on('postgres_changes',
                            { event: '*', schema: 'public', table: 'employee_tasks' },
                            (payload) => {
                                console.log(' Real-time task change:', payload.eventType);
                                // Update the specific task status
                                if (payload.eventType === 'INSERT' || payload.eventType === 'UPDATE') {
                                    const { employee_id, template_id, status } = payload.new;
                                    setEmployeeTasks(prev => ({
                                        ...prev,
                                        [employee_id]: {
                                            ...prev[employee_id],
                                            [template_id]: status
                                        }
                                    }));
                                }
                            }
                        )
                        .subscribe((status) => {
                            console.log(' Tasks subscription:', status);
                        });

                    // Subscribe to resources table changes
                    const resourcesChannel = supabase
                        .channel('realtime-resources')
                        .on('postgres_changes',
                            { event: '*', schema: 'public', table: 'resources' },
                            async (payload) => {
                                console.log(' Real-time resource change:', payload.eventType);
                                // Refetch all resources to maintain order
                                const { data } = await supabase.from('resources').select('*').order('display_order');
                                if (data) {
                                    setResources(data.map(r => ({
                                        ...r,
                                        avatar: r.avatar_initials,
                                        displayOrder: r.display_order
                                    })));
                                }
                            }
                        )
                        .subscribe((status) => {
                            console.log(' Resources subscription:', status);
                        });

                    // Stocker les channels pour cleanup
                    window._realtimeChannels = { employeesChannel, tasksChannel, resourcesChannel };
                }, 300); // Delai de 300ms apres le chargement
                
                // Cleanup subscriptions on unmount
                return () => {
                    clearTimeout(timeoutId);
                    if (window._realtimeChannels && supabase) {
                        console.log(' Cleaning up real-time subscriptions');
                        supabase.removeChannel(window._realtimeChannels.employeesChannel);
                        supabase.removeChannel(window._realtimeChannels.tasksChannel);
                        supabase.removeChannel(window._realtimeChannels.resourcesChannel);
                    }
                };
            }, [useSupabase, isLoading]); // Dependre de isLoading

            // Mise a jour simplifiee des phases (acces direct DB)
            const updatePhaseDirect = async (id, field, value) => {
                 setPhaseTemplates(phases => phases.map(p => p.id === id ? { ...p, [field]: value } : p));
                 // Persist
                 if(useSupabase && supabase) {
                      const dbField = field === 'startOffset' ? 'start_offset' : field; // mapping simple
                      await supabase.from('phases').update({ [dbField]: value }).eq('id', id);
                 }
            };



            // NOTE: Auto-save effects removed in favor of direct DB updates in handler functions

            // CRITICAL: Memoize selectedEmployee to prevent infinite useEffect loops
            // The fallback object was being recreated on every render, triggering effects
            const selectedEmployee = useMemo(() => {
                return employees.find(e => e.id === selectedEmployeeId) || employees[0] || { 
                    id: 0, 
                    name: 'Chargement...', 
                    role: '...', 
                    avatarUrl: null, 
                    startDate: new Date('2026-01-01').toISOString().split('T')[0],
                    endDate: new Date('2026-01-01').toISOString().split('T')[0]
                };
            }, [employees, selectedEmployeeId]);

            // Helper pour securiser les dates (defaut 2026, minimum 2026-01-01)
            // Utilise TaskManager.ensureMinDate2026 pour garantir la coherence
            const getValidDate = (dateStr) => {
                return TaskManager.ensureMinDate2026(dateStr);
            };

            /**
             * phases - Phases calculees pour l'employe selectionne
             * -----------------------------------------------------
             * Calcule les dates de debut/fin de chaque phase basees sur:
             * - startDate de l'employe
             * - startOffset de la phase (jours apres le debut)
             * - duration de la phase (duree en jours)
             * 
             * FORMAT RETOURNE:
             * - startDate: Date de debut calculee (ISO string)
             * - endDate: Date de fin calculee (ISO string)
             * - Toutes les proprietes de phaseTemplates
             */
            const phases = useMemo(() => {
                if (!selectedEmployee) return [];
                const startDate = getValidDate(selectedEmployee.startDate);
                
                return phaseTemplates.map(pt => {
                    // Calcul securise
                    const startMs = startDate.getTime() + (pt.startOffset || 0) * 86400000;
                    const endMs = startDate.getTime() + ((pt.startOffset || 0) + (pt.duration || 1)) * 86400000;
                    
                    return {
                        ...pt,
                        startDate: new Date(startMs).toISOString().split('T')[0],
                        endDate: new Date(endMs).toISOString().split('T')[0]
                    };
                });
            }, [selectedEmployee, phaseTemplates]);

            const [tasks, setTasks] = useState([]);

            /**
             * Generation des taches pour l'employe selectionne
             * -------------------------------------------------
             * Utilise TaskManager.generateTasks pour fusionner:
             * - taskTemplates: Templates de base depuis la DB
             * - employeeTasks: Statuts sauvegardes pour cet employe
             * 
             * OPTIMISATION: Ne met a jour que si les taches ont reellement change
             * (comparaison des IDs + statuts) pour eviter les re-renders inutiles.
             * 
             * DEPENDANCES CRITIQUES:
             * - selectedEmployee?.id: Change quand on selectionne un autre employe
             * - selectedEmployee?.startDate: Change si la date de debut est modifiee
             * - taskTemplates.length: Change quand des templates sont ajoutes/supprimes
             * - employeeTasks: Change quand les statuts sont sauvegardes
             * 
             *   CRITIQUE: employeeTasks DOIT etre dans les dependances pour recharger
             *     les statuts apres sauvegarde
             */
            useEffect(() => {
                if (!selectedEmployee || !selectedEmployee.id) return;
                
                const generatedTasks = TaskManager.generateTasks(selectedEmployee, taskTemplates, employeeTasks);
                
                // Log pour debugging
                const statusCounts = {
                    pending: generatedTasks.filter(t => t.status === 'pending').length,
                    inProgress: generatedTasks.filter(t => t.status === 'inProgress').length,
                    completed: generatedTasks.filter(t => t.status === 'completed').length
                };
                console.log(` Taches generees pour ${selectedEmployee.name}:`, statusCounts);
                
                // CRITICAL: Only update if tasks actually changed to prevent infinite loops
                setTasks(prevTasks => {
                    const prevIds = prevTasks.map(t => t.id + t.status).join(',');
                    const newIds = generatedTasks.map(t => t.id + t.status).join(',');
                    if (prevIds === newIds) {
                        return prevTasks; // No change, return same reference
                    }
                    return generatedTasks;
                });
            }, [selectedEmployee?.id, selectedEmployee?.startDate, taskTemplates.length, employeeTasks]);

            const stats = useMemo(() => {
                const total = tasks.length;
                const completed = tasks.filter(t => t.status === 'completed').length;
                const inProgress = tasks.filter(t => t.status === 'inProgress').length;
                const pending = tasks.filter(t => t.status === 'pending').length;
                return { total, completed, inProgress, pending, progress: total > 0 ? Math.round((completed / total) * 100) : 0 };
            }, [tasks]);

            // Confetti Trigger
            useEffect(() => {
                if (stats.total > 0 && stats.completed === stats.total) {
                    triggerConfetti();
                    showNotification(' Felicitations ! Parcours termine !', 'success');
                }
            }, [stats.completed, stats.total]);

            const filteredTasks = useMemo(() => {
                return tasks.filter(task => {
                    const matchesSearch = task.title.toLowerCase().includes(searchTerm.toLowerCase());
                    const matchesStatus = filterStatus === 'all' || task.status === filterStatus;
                    const matchesUrgent = !showUrgent || task.priority === 'high';
                    return matchesSearch && matchesStatus && matchesUrgent;
                });
            }, [tasks, searchTerm, filterStatus, showUrgent]);

            // Notification Toast Component
            // This component definition is no longer used directly as a component,
            // but its logic is integrated into the main render for top-center display.
            // The `notification` state is now directly rendered.

            // Fonction utilitaire pour gestion erreurs Supabase
            const handleSupabaseError = (error, context) => {
                console.error(`Erreur Supabase (${context}):`, error);
                showNotification(`Erreur sauvegarde (${context})`, 'error');
            };

            /**
             * Sauvegarde un champ d'une tache (template) dans Supabase
             * ----------------------------------------------------------
             * Gere la conversion du format React vers DB et l'extraction du templateId.
             * 
             * FORMAT TASK ID:
             * - Peut etre un nombre (templateId direct) ou "employeeId-templateId"
             * - Extrait automatiquement le templateId pour la requete DB
             * 
             * MAPPING DES CHAMPS:
             * - phaseId -> phase_id
             * - dayOffset -> day_offset
             * - assignedTo -> assigned_to
             * - Autres champs: utilisent le nom tel quel
             * 
             * @param {string|number} taskId - ID de la tache (format "employeeId-templateId" ou nombre)
             * @param {string} field - Nom du champ en format React (camelCase)
             * @param {any} value - Nouvelle valeur
             * @param {string|null} dbFieldName - Nom du champ en DB (optionnel, auto-mappe si null)
             * @returns {Promise<boolean>} true si succes, false sinon
             */
            const saveTaskField = async (taskId, field, value, dbFieldName = null) => {
                if (!useSupabase || !supabase) {
                    console.warn(' Supabase non disponible pour sauvegarder', field);
                    return false;
                }
                
                try {
                    //  FIX: Extraire le templateId reel si taskId est au format "employeeId-templateId"
                    let templateId = taskId;
                    if (typeof taskId === 'string' && taskId.includes('-')) {
                        templateId = parseInt(taskId.split('-')[1]);
                        if (isNaN(templateId)) {
                            console.error(` Impossible d'extraire templateId de ${taskId}`);
                            return false;
                        }
                    } else {
                        templateId = parseInt(taskId);
                        if (isNaN(templateId)) {
                            console.error(` taskId invalide: ${taskId}`);
                            return false;
                        }
                    }
                    
                    const dbField = dbFieldName || (field === 'phaseId' ? 'phase_id' : 
                                                     field === 'dayOffset' ? 'day_offset' : 
                                                     field === 'startDate' ? 'start_date' :
                                                     field === 'endDate' ? 'end_date' :
                                                     field === 'assignedTo' ? 'assigned_to' : field);
                    
                    console.log(` Sauvegarde ${field} (${dbField}) pour tache template ${templateId}:`, value);
                    
                    const { data, error } = await supabase
                        .from('task_templates')
                        .update({ [dbField]: value })
                        .eq('id', templateId)
                        .select(); // Retourner les donnees pour verifier
                    
                    if (error) {
                        //  FIX: Gerer les erreurs de colonnes manquantes gracieusement
                        if (error.message && (error.message.includes('column') || error.message.includes('not found') || error.message.includes('schema cache'))) {
                            console.warn(` Colonne ${dbField} non trouvee dans task_templates. Migration SQL necessaire.`);
                            console.warn(`   Erreur complete:`, error);
                            showNotification(`Colonne ${dbField} manquante. Executez la migration 013_add_task_dates.sql dans Supabase.`, 'warning');
                            // Ne pas bloquer l'UI, retourner false mais continuer
                            return false;
                        }
                        console.error(` Erreur sauvegarde ${field}:`, error);
                        showNotification(`Erreur sauvegarde ${field}: ${error.message || error.details}`, 'error');
                        return false;
                    }
                    
                    if (data && data.length > 0) {
                        console.log(` ${field} sauvegarde avec succes pour tache template ${templateId}`);
                        // Feedback visuel discret (pas de notification pour chaque champ)
                        return true;
                    } else {
                        console.warn(` Aucune donnee retournee pour tache template ${templateId}`);
                        return false;
                    }
                } catch (e) {
                    console.error(` Exception lors de la sauvegarde ${field}:`, e);
                    handleSupabaseError(e, `Save Task ${field}`);
                    return false;
                }
            };

            /**
             * Change le statut d'une tache (cycle: pending -> inProgress -> completed -> pending)
             * ---------------------------------------------------------------------------------
             * PATTERN OPTIMISTIC UPDATE:
             * 1. Mise a jour UI immediate (setTasks + setEmployeeTasks)
             * 2. Sauvegarde en arriere-plan via TaskManager.saveTaskStatus
             * 3. Rollback automatique si erreur
             * 
             * FORMAT TASK ID:
             * - Format: "employeeId-templateId" (ex: "1-19")
             * - templateId est extrait pour la requete DB
             * 
             * @param {string} taskId - ID de la tache au format "employeeId-templateId"
             */
            const toggleTaskStatus = async (taskId) => {
                if (!selectedEmployee || !selectedEmployee.id) {
                    showNotification('Erreur: Aucun employe selectionne', 'error');
                    return;
                }

                // Trouver la tache
                const task = tasks.find(t => t.id === taskId);
                if (!task || !task.templateId) {
                    console.error(' Tache introuvable:', taskId);
                    showNotification('Erreur: Tache introuvable', 'error');
                    return;
                }

                // Calculer le nouveau statut
                const statuses = ['pending', 'inProgress', 'completed'];
                const currentIndex = statuses.indexOf(task.status);
                const newStatus = statuses[(currentIndex + 1) % statuses.length];
                const previousStatus = task.status;

                console.log(` Changement statut: Task=${task.templateId}, Emp=${selectedEmployee.id}, ${previousStatus} -> ${newStatus}`);

                // Optimistic Update IMMEDIAT
                setTasks(prev => prev.map(t => 
                    t.id === taskId ? { ...t, status: newStatus } : t
                ));
                setEmployeeTasks(prev => ({
                    ...prev,
                    [selectedEmployee.id]: {
                        ...prev[selectedEmployee.id],
                        [task.templateId]: newStatus
                    }
                }));

                // Sauvegarde avec TaskManager (robuste avec retry)
                if (useSupabase && supabase) {
                    const success = await TaskManager.saveTaskStatus(
                        supabase,
                        selectedEmployee.id,
                        task.templateId,
                        newStatus,
                        (result) => {
                            console.log(` Statut sauvegarde:`, result);
                        },
                        (error) => {
                            console.error(' Erreur sauvegarde:', error);
                            // Rollback automatique
                            setTasks(prev => prev.map(t => 
                                t.id === taskId ? { ...t, status: previousStatus } : t
                            ));
                            setEmployeeTasks(prev => ({
                                ...prev,
                                [selectedEmployee.id]: {
                                    ...prev[selectedEmployee.id],
                                    [task.templateId]: previousStatus
                                }
                            }));
                            showNotification(`Erreur sauvegarde: ${error}`, 'error');
                        }
                    );
                    
                    if (success) {
                        triggerSaveIndicator('Statut sauvegarde');
                    }
                }
            };



            /**
             * Met a jour un champ d'une tache (template)
             * --------------------------------------------
             * PATTERN OPTIMISTIC UPDATE:
             * 1. Mise a jour UI immediate (setTasks + setTaskTemplates)
             * 2. Sauvegarde en DB via saveTaskField
             * 
             * FORMAT TASK ID:
             * - Format: "employeeId-templateId" (ex: "1-19")
             * - Extrait templateId pour la requete DB
             * 
             * @param {string} taskId - ID de la tache au format "employeeId-templateId"
             * @param {string} field - Nom du champ a mettre a jour (camelCase)
             * @param {any} value - Nouvelle valeur
             */
            const updateTask = async (taskId, field, value) => {
                //  FIX: dueDate n'existe pas en DB, ne jamais essayer de le sauvegarder
                if (field === 'dueDate') {
                    console.error(' Tentative de sauvegarder dueDate qui n\'existe pas en DB. Utilisez dayOffset a la place.');
                    showNotification('Erreur: dueDate ne peut pas etre sauvegarde directement. Utilisez le calendrier pour modifier la date.', 'error');
                    return;
                }
                
                // Sauvegarder la valeur originale pour rollback si necessaire
                const originalTask = tasks.find(t => t.id === taskId);
                const originalValue = originalTask ? originalTask[field] : null;
                
                // Optimistic UI - Mise a jour immediate pour reactivite
                setTasks(prev => prev.map(t => t.id === taskId ? { ...t, [field]: value } : t));

                // Extraire le templateId de maniere securisee
                // Format taskId: "employeeId-templateId" (ex: "1-19" ou "1--1735123456789" pour IDs temporaires)
                let originalTaskId;
                
                if (typeof taskId === 'string' && taskId.includes('-')) {
                    // Trouver le premier tiret qui separe employeeId et templateId
                    const firstDashIndex = taskId.indexOf('-');
                    const templateIdStr = taskId.substring(firstDashIndex + 1);
                    
                    // Parser le templateId (peut etre negatif pour les IDs temporaires)
                    originalTaskId = parseInt(templateIdStr);
                    
                    if (isNaN(originalTaskId)) {
                        console.error(` Impossible d'extraire templateId de ${taskId} (templateIdStr: ${templateIdStr})`);
                        showNotification('Erreur: ID de tache invalide', 'error');
                        // Rollback optimistic update
                        if (originalValue !== null) {
                            setTasks(prev => prev.map(t => t.id === taskId ? { ...t, [field]: originalValue } : t));
                        }
                        return;
                    }
                } else {
                    // Si ce n'est pas un string avec tiret, c'est directement le templateId
                    originalTaskId = parseInt(taskId);
                    if (isNaN(originalTaskId)) {
                        console.error(` taskId invalide: ${taskId}`);
                        showNotification('Erreur: ID de tache invalide', 'error');
                        // Rollback optimistic update
                        if (originalValue !== null) {
                            setTasks(prev => prev.map(t => t.id === taskId ? { ...t, [field]: originalValue } : t));
                        }
                    }
                }
                
                //  FIX: Si c'est un ID temporaire negatif, ne pas essayer de sauvegarder dans Supabase
                // La tache sera sauvegardee quand elle sera creee dans la DB
                if (originalTaskId < 0) {
                    console.log(` Tache avec ID temporaire ${originalTaskId} - mise a jour locale uniquement`);
                    // Mettre a jour localement seulement dans taskTemplates
                    const updatedTemplates = taskTemplates.map(t => t.id === originalTaskId ? { ...t, [field]: value } : t);
                    setTaskTemplates(updatedTemplates);
                    // Pas de notification pour eviter de spammer l'utilisateur
                    return;
                }
                
                // Sauvegarder l'etat precedent des templates pour rollback
                const previousTemplates = [...taskTemplates];
                
                // Mettre a jour les templates localement
                const updatedTemplates = taskTemplates.map(t => t.id === originalTaskId ? { ...t, [field]: value } : t);
                setTaskTemplates(updatedTemplates);

                // Sauvegarder dans Supabase en utilisant saveTaskField pour une meilleure gestion d'erreur
                if (useSupabase && supabase) {
                    try {
                        const success = await saveTaskField(taskId, field, value);
                        if (success) {
                            showNotification('Modification sauvegardee !', 'success');
                        } else {
                            // Rollback optimistic update en cas d'echec
                            if (originalValue !== null) {
                                setTasks(prev => prev.map(t => t.id === taskId ? { ...t, [field]: originalValue } : t));
                            }
                            setTaskTemplates(previousTemplates); // Restaurer l'etat precedent
                        }
                    } catch (e) {
                        console.error(' Exception dans updateTask:', e);
                        handleSupabaseError(e, 'Update Task');
                        // Rollback optimistic update
                        if (originalValue !== null) {
                            setTasks(prev => prev.map(t => t.id === taskId ? { ...t, [field]: originalValue } : t));
                        }
                        setTaskTemplates(previousTemplates);
                    }
                } else {
                    // Mode local seulement
                    showNotification('Modification enregistree (mode local)', 'success');
                }
            };

            /**
             * Supprime une tache (template) et nettoie les assignations
             * ------------------------------------------------------------
             * CASCADE DELETE:
             * 1. Supprime toutes les entrees dans employee_tasks pour ce template
             *    (nettoie les statuts sauvegardes pour tous les employes)
             * 2. Supprime le template dans task_templates
             * 
             * FORMAT TASK ID:
             * - Peut etre un nombre (templateId direct) ou "employeeId-templateId"
             * - Extrait automatiquement le templateId pour les requetes DB
             * 
             * OPTIMISTIC UPDATE:
             * - Supprime immediatement de l'UI
             * - Rollback si erreur (reload complet de la page)
             * 
             * @param {string|number} taskId - ID de la tache a supprimer
             */
            const deleteTask = async (taskId) => {
                // Extraire le templateId de maniere securisee
                let originalTaskId;
                if (typeof taskId === 'string' && taskId.includes('-')) {
                    originalTaskId = parseInt(taskId.split('-')[1]);
                    if (isNaN(originalTaskId)) {
                        console.error(` Impossible d'extraire templateId de ${taskId}`);
                        showNotification('Erreur: ID de tache invalide', 'error');
                        return;
                    }
                } else {
                    originalTaskId = parseInt(taskId);
                    if (isNaN(originalTaskId)) {
                        console.error(` taskId invalide: ${taskId}`);
                        showNotification('Erreur: ID de tache invalide', 'error');
                        return;
                    }
                }
                
                // Si c'est un ID temporaire negatif, supprimer directement de l'UI
                if (originalTaskId < 0) {
                    setTaskTemplates(prev => prev.filter(t => t.id !== originalTaskId));
                    setTasks(prev => prev.filter(t => t.id !== taskId));
                    showNotification('Tache supprimee (non sauvegardee)', 'success');
                    return;
                }
                
                if(!confirm('Supprimer cette tache ? (Cela la retirera aussi du parcours des employes actuels)')) return;
                
                // Optimistic: Supprimer immediatement de l'UI
                setTaskTemplates(prev => prev.filter(t => t.id !== originalTaskId));
                setTasks(prev => prev.filter(t => {
                    // Supprimer toutes les instances de cette tache pour tous les employes
                    const taskTemplateId = typeof t.id === 'string' ? parseInt(t.id.split('-')[1]) : t.id;
                    return taskTemplateId !== originalTaskId;
                }));

                if (useSupabase && supabase) {
                    try {
                        // 1. Delete assignments in employee_tasks
                        const { error: assignError } = await supabase
                            .from('employee_tasks')
                            .delete()
                            .eq('template_id', originalTaskId);
                        
                        if (assignError) console.warn('Error clearing assignments:', assignError);

                        // 2. Delete the template
                        const { error } = await supabase
                            .from('task_templates')
                            .delete()
                            .eq('id', originalTaskId);
                            
                        if (error) throw error;
                        showNotification('Tache supprimee', 'success');
                    } catch (e) {
                        console.error(' Erreur suppression tache:', e);
                        handleSupabaseError(e, 'Delete Task');
                        // Rollback: Recharger les taches depuis la DB
                        setTimeout(() => {
                            reloadTaskTemplates();
                        }, 1000);
                    }
                } else {
                    showNotification('Tache supprimee (mode local)', 'success');
                }
            };

            /**
             * Ajoute une nouvelle tache (template) a une phase
             * --------------------------------------------------
             * PATTERN OPTIMISTIC UPDATE avec ID temporaire:
             * 1. Genere un ID temporaire negatif (-Date.now()) pour eviter conflits DB
             * 2. Ajoute immediatement a l'UI (optimistic update)
             * 3. Insere dans Supabase (sans specifier l'ID - laisse DB generer)
             * 4. Remplace l'ID temporaire par l'ID reel retourne par la DB
             * 5. Rollback si erreur (supprime l'item avec ID temporaire)
             * 
             * GESTION CONFLITS:
             * - Detecte les erreurs 409 (conflit cle primaire)
             * - Recharge automatiquement les taches depuis la DB
             * 
             *   CRITIQUE: Ne JAMAIS utiliser Math.max() pour generer des IDs
             *     (risque de conflit avec IDs existants non charges)
             * 
             * @param {number} phaseId - ID de la phase a laquelle ajouter la tache
             */
            const addTask = async (phaseId) => {
                // ID temporaire negatif: evite conflits car auto-increment DB commence a 1
                const tempId = -Date.now(); // ID temporaire unique et negatif
                const newTaskTemplate = {
                    id: tempId, // ID temporaire negatif, sera remplace par l'ID de la DB
                    phaseId,
                    title: 'Nouvelle tache',
                    description: 'Description de la tache...',
                    assignedTo: [], // Important: DB expects JSONB, make sure mapping handles this
                    priority: 'medium',
                    category: 'autre',
                    dayOffset: 0
                };
                
                // Optimistic update avec ID temporaire
                setTaskTemplates(prev => [...prev, newTaskTemplate]);

                if (useSupabase && supabase) {
                   try {
                        const { data, error } = await supabase
                            .from('task_templates')
                            .insert([{
                                // NE PAS inclure 'id' - laisser Supabase le generer automatiquement
                                phase_id: phaseId,
                                title: newTaskTemplate.title,
                                description: newTaskTemplate.description,
                                priority: newTaskTemplate.priority,
                                category: newTaskTemplate.category,
                                day_offset: 0,
                                assigned_to: []
                            }])
                            .select();

                        if (error) {
                            // Remove optimistic update on any error
                            setTaskTemplates(prev => prev.filter(t => t.id !== tempId));
                            
                            // Handle 409 conflict specifically
                            if (error.code === '23505' || error.message?.includes('duplicate') || error.status === 409 || error.code === 'PGRST116') {
                                // Conflict: task might already exist, reload from DB
                                console.warn('Conflit lors de l\'ajout de tache, rechargement depuis la DB...', error);
                                showNotification('Tache deja existante ou conflit detecte. Rechargement...', 'error');
                                // Reload tasks after a short delay
                                setTimeout(() => {
                                    reloadTaskTemplates();
                                }, 1000);
                            } else {
                                // Other error
                                throw error;
                            }
                        } else if (data && data[0]) {
                            // Replace optimistic item with real DB item (with correct ID from DB)
                            setTaskTemplates(prev => prev.map(t => t.id === tempId ? DataMapper.taskTemplateToReact(data[0]) : t));
                            showNotification('Nouvelle tache ajoutee', 'success');
                        } else {
                            // Pas de donnees retournees, recharger pour synchroniser
                            console.warn(' Aucune donnee retournee apres insertion, rechargement...');
                            setTimeout(() => reloadTaskTemplates(), 500);
                        }
                   } catch (e) {
                       console.error(' Erreur ajout tache:', e);
                       // Remove optimistic update on error
                       setTaskTemplates(prev => prev.filter(t => t.id !== tempId));
                       const errorMessage = e.message || e.details || 'Erreur inconnue lors de l\'ajout de la tache';
                       handleSupabaseError(e, 'Add Task');
                       showNotification(`Erreur lors de l'ajout: ${errorMessage}`, 'error');
                       
                       // En cas d'erreur, recharger pour synchroniser
                       setTimeout(() => {
                           reloadTaskTemplates();
                       }, 500);
                   }
                } else {
                     showNotification('Nouvelle tache ajoutee (Local)', 'success');
                }
            };

            // Phase collapse and View Mode state
            const [collapsedPhases, setCollapsedPhases] = useState({});
            const togglePhaseCollapse = (phaseId) => setCollapsedPhases(prev => ({ ...prev, [phaseId]: !prev[phaseId] }));
            const [showStats, setShowStats] = useState(true);
            const [notification, setNotification] = useState(null);
            const [dragging, setDragging] = useState(false); // State for drag feedback

            // Helper to show notifications
            const showNotification = (message, type = 'success') => {
                setNotification({ message, type });
                // Exposer globalement pour que sendEmailViaResend puisse l'utiliser
                window.showNotification = showNotification;
            };

            const statusColors = { pending: 'bg-gray-100 text-gray-700', inProgress: 'bg-blue-100 text-blue-700', completed: 'bg-green-100 text-green-700' };
            const priorityColors = { low: 'bg-gray-100', medium: 'bg-yellow-100 text-yellow-700', high: 'bg-orange-100 text-orange-700' };

            // DatePicker est maintenant defini au niveau superieur (avant AdminPanel), accessible partout

            const TaskCard = ({ task, onUpdate, onDelete, onOpenResourcePanel }) => {
                const [expanded, setExpanded] = useState(false);
                const [editing, setEditing] = useState(null);
                const [editValue, setEditValue] = useState('');
                const [showDeleteConfirm, setShowDeleteConfirm] = useState(false);
                const phase = phases.find(p => p.id === task.phaseId);
                const assignedResources = resources.filter(r => task.assignedTo.includes(r.id));
                const priorityBg = { low: '#10B981', medium: '#F59E0B', high: '#EF4444' };
                
                const startEdit = (field, value) => { setEditing(field); setEditValue(value); };
                const saveEdit = (field) => {
                    if (field === 'dueDate') {
                        //  FIX: Mettre a jour startDate et endDate directement
                        // Forcer la date dans Q1 2026
                        const validDate = TaskManager.ensureQ1_2026(editValue);
                        const dateStr = validDate.toISOString().split('T')[0];
                        
                        // Mettre a jour startDate et endDate
                        onUpdate(task.id, 'startDate', dateStr);
                        onUpdate(task.id, 'endDate', dateStr);
                    } else {
                        if (editValue !== task[field]) {
                            onUpdate(task.id, field, editValue);
                        }
                    }
                    setEditing(null);
                };

                // Multi-select logic for resources
                const toggleResource = (resourceId) => {
                    const current = task.assignedTo || [];
                    const updated = current.includes(resourceId) 
                        ? current.filter(id => id !== resourceId)
                        : [...current, resourceId];
                    onUpdate(task.id, 'assignedTo', updated);
                };

                const cyclePriority = (e) => {
                    e.stopPropagation();
                    const priorities = ['low', 'medium', 'high'];
                    const currentIdx = priorities.indexOf(task.priority);
                    onUpdate(task.id, 'priority', priorities[(currentIdx + 1) % 3]);
                };
                
                return (
                    <div 
                        className="bg-white border-2 rounded-lg mb-3 task-hover transition-all flex overflow-visible"
                        draggable="true"
                        onDragStart={(e) => { e.dataTransfer.setData('taskId', task.id); setDragging(true); }}
                        onDragEnd={() => setDragging(false)}
                    >
                        {/* Priority indicator bar */}
                        <div className="priority-indicator" style={{ backgroundColor: priorityBg[task.priority] }} onClick={cyclePriority} title="Cliquer pour changer la priorite"></div>
                        
                        <div className="flex-1 p-3">
                            {/* Header row */}
                            <div className="flex items-center gap-2">
                                <span className="text-gray-300 draggable cursor-grab"><Icons.GripVertical /></span>
                                <button onClick={() => toggleTaskStatus(task.id)} className="hover:scale-110 transition-transform">
                                    {task.status === 'completed' ? <span className="text-green-600"><Icons.CheckCircle /></span> : task.status === 'inProgress' ? <span className="text-blue-600"><Icons.Clock /></span> : <span className="text-gray-400"><Icons.Circle /></span>}
                                </button>
                                {editing === 'title' ? (
                                    <input autoFocus className="editable-input flex-1 font-semibold" value={editValue} onChange={e => setEditValue(e.target.value)} onBlur={() => saveEdit('title')} onKeyDown={e => e.key === 'Enter' && saveEdit('title')} />
                                ) : (
                                    <h4 onClick={() => startEdit('title', task.title)} className={`font-semibold flex-1 editable ${task.status === 'completed' ? 'line-through text-gray-500' : 'text-gray-900'}`}>{task.title}</h4>
                                )}
                                <button onClick={() => setExpanded(!expanded)} className="text-gray-400 hover:text-gray-600 p-1">
                                    <span className={`chevron-rotate ${expanded ? 'chevron-down' : 'chevron-right'}`}><Icons.ChevronDown /></span>
                                </button>
                                {onDelete && (
                                    showDeleteConfirm ? (
                                        <div className="flex items-center gap-2 animate-bounce-in">
                                            <button onClick={() => onDelete(task.id)} className="text-white bg-red-500 hover:bg-red-600 px-2 py-0.5 rounded text-xs font-bold">Confirmer ?</button>
                                            <button onClick={() => setShowDeleteConfirm(false)} className="text-gray-400 hover:text-gray-600"><Icons.X /></button>
                                        </div>
                                    ) : (
                                        <button onClick={() => setShowDeleteConfirm(true)} className="text-red-400 hover:text-red-600 p-1"><Icons.Trash /></button>
                                    )
                                )}
                            </div>
                            
                                {/* Compact info row - Now with full edit capabilities */}
                            <div className="flex flex-wrap gap-2 mt-2 text-xs items-center">
                                <span className={`px-2 py-0.5 rounded-full ${statusColors[task.status]}`}>{task.status === 'pending' ? ' Attente' : task.status === 'inProgress' ? ' En cours' : ' Fait'}</span>
                                {editing === 'priority' ? (
                                    <select autoFocus className="editable-input text-xs" value={editValue} onChange={(e) => { onUpdate(task.id, 'priority', e.target.value); setEditing(null); }} onBlur={() => setEditing(null)}>
                                        <option value="low"> Basse</option>
                                        <option value="medium"> Moyenne</option>
                                        <option value="high"> Haute</option>
                                    </select>
                                ) : (
                                    <span onClick={() => startEdit('priority', task.priority)} className="px-2 py-0.5 rounded-full editable flex items-center gap-1" style={{ backgroundColor: priorityBg[task.priority] + '20', color: priorityBg[task.priority] }}>
                                        <span className="w-2 h-2 rounded-full" style={{ backgroundColor: priorityBg[task.priority] }}></span>
                                        {task.priority === 'high' ? 'Haute' : task.priority === 'medium' ? 'Moyenne' : 'Basse'}
                                    </span>
                                )}
                                
                                {editing === 'dueDate' ? (
                                    <div className="flex items-center gap-1">
                                        <span className="text-[10px] font-bold text-gray-400 uppercase">Echeance :</span>
                                        <DatePicker
                                            value={editValue}
                                            onChange={(val) => setEditValue(val)}
                                            onBlur={() => saveEdit('dueDate')}
                                            placeholder="Date a determiner"
                                            className="px-2 py-0.5 rounded-full text-xs"
                                            min="2026-01-01"
                                            max="2026-03-31"
                                        />
                                    </div>
                                ) : (
                                    <div className="flex items-center gap-1">
                                        <span className="text-[10px] font-bold text-gray-400 uppercase">Echeance :</span>
                                        <span onClick={() => {
                                            // Forcer la date dans Q1 2026 avant d'editer
                                            const validDate = TaskManager.ensureQ1_2026(task.dueDate || task.endDate || '2026-01-01');
                                            startEdit('dueDate', validDate.toISOString().split('T')[0]);
                                        }} className={`px-2 py-0.5 rounded-full editable ${task.dueDate ? 'bg-gray-100' : 'bg-red-50 text-red-500 border border-red-200'}`}>
                                             {(() => {
                                                const dateToShow = task.dueDate || task.endDate || task.startDate;
                                                if (!dateToShow) return 'Date a determiner';
                                                const validDate = TaskManager.ensureQ1_2026(dateToShow);
                                                return validDate.toLocaleDateString('fr-FR', { day: '2-digit', month: '2-digit', year: 'numeric' });
                                            })()}
                                        </span>
                                    </div>
                                )}

                                {/* Category Edit */}
                                {editing === 'category' ? (
                                    <select autoFocus className="editable-input text-xs" value={editValue} onChange={(e) => { onUpdate(task.id, 'category', e.target.value); setEditing(null); }} onBlur={() => setEditing(null)}>
                                        <option value="administratif">Administratif</option>
                                        <option value="technique">Technique</option>
                                        <option value="formation">Formation</option>
                                        <option value="autre">Autre</option>
                                        <option value="">Non specifie</option>
                                    </select>
                                ) : (
                                    <span onClick={() => startEdit('category', task.category || '')} className={`px-2 py-0.5 rounded-full editable uppercase text-[10px] tracking-wider ${task.category ? 'bg-indigo-50 text-indigo-700' : 'bg-gray-100 text-gray-400 italic'}`}>
                                        {task.category || 'NON SPECIFIE'}
                                    </span>
                                )}
                                
                                {/* Resource Quick Add/Remove - Bouton seulement, panneau rendu en dehors */}
                                <div className="flex items-center gap-1 ml-auto">
                                     <div 
                                         className="flex -space-x-1 cursor-pointer" 
                                         onClick={(e) => {
                                             e.stopPropagation();
                                             // Utiliser le state global passe en prop
                                             if (onOpenResourcePanel) {
                                                 onOpenResourcePanel(task.id);
                                             }
                                         }}
                                     >
                                        {/* Toujours afficher le bouton + Resp pour permettre l'edition */}
                                        <span className={`px-2 py-0.5 rounded-full border transition-all ${
                                            assignedResources.length === 0 
                                                ? 'bg-gray-50 text-gray-400 border-dashed border-gray-300 hover:border-blue-400 hover:text-blue-500' 
                                                : 'bg-blue-50 text-blue-600 border-blue-300 hover:bg-blue-100'
                                        }`}>
                                            {assignedResources.length === 0 ? '+ Resp' : ' Modifier'}
                                        </span>
                                        {assignedResources.map(r => (
                                            <span key={r.id} className="w-6 h-6 rounded-full flex items-center justify-center text-[10px] text-white ring-2 ring-white cursor-pointer relative transition-all hover:scale-110" style={{ backgroundColor: r.color }} title={r.name}>
                                                {r.name.charAt(0)}
                                            </span>
                                        ))}
                                     </div>
                                     <div className="text-xs text-gray-600 font-medium whitespace-nowrap hidden md:block">
                                        {assignedResources.length > 0 ? assignedResources.map(r => r.name).join(', ') : 'Aucun responsable'}
                                     </div>
                                </div>
                            </div>
                            
                            
                            {/* Expanded details */}
                            <div className={`collapsible-content ${expanded ? '' : 'collapsed'}`} style={{ maxHeight: expanded ? '500px' : '0' }}>
                                <div className="mt-3 pt-3 border-t space-y-2">
                                    {editing === 'description' ? (
                                        <textarea autoFocus className="editable-input w-full text-sm" rows="3" value={editValue} onChange={e => setEditValue(e.target.value)} onBlur={() => saveEdit('description')} placeholder="Ajouter une description..." />
                                    ) : (
                                        <div onClick={() => startEdit('description', task.description || '')} className="text-sm text-gray-600 editable min-h-[40px] whitespace-pre-wrap">{task.description || 'Ajouter une description...'}</div>
                                    )}
                                    <div className="flex flex-wrap gap-1 mt-2">
                                        {assignedResources.map(r => <span key={r.id} className="text-xs px-2 py-1 rounded-full flex items-center gap-1 border" style={{ backgroundColor: r.color + '10', borderColor: r.color + '30', color: r.color }}><Icons.User />{r.name}</span>)}
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                );
            };

            // KANBAN VIEW COMPONENT
            /**
             * KanbanView - Vue Kanban des taches
             * -----------------------------------
             * Affiche les taches dans 3 colonnes (A faire, En cours, Termine).
             * Support drag & drop pour changer le statut.
             * 
             * COLONNES:
             * - pending: A faire
             * - inProgress: En cours
             * - completed: Termine
             * 
             * DRAG & DROP:
             * - Utilise dataTransfer pour passer le taskId
             * - handleDrop met a jour le statut via toggleTaskStatus
             */
            const KanbanView = () => {
                const columns = [
                    { id: 'pending', title: 'A faire', icon: <Icons.Circle />, bg: 'bg-gray-50', border: 'border-gray-200' },
                    { id: 'inProgress', title: 'En cours', icon: <Icons.Clock />, bg: 'bg-blue-50', border: 'border-blue-200' },
                    { id: 'completed', title: 'Termine', icon: <Icons.CheckCircle />, bg: 'bg-green-50', border: 'border-green-200' }
                ];

                const handleDrop = (e, status) => {
                    const taskId = e.dataTransfer.getData('taskId');
                    if (taskId) {
                        // Assuming toggleTaskStatus handles logic for now, but really we should update status directly
                        // Reusing toggleTaskStatus which cycles, might need direct set.
                        // Ideally: onUpdate(taskId, 'status', status);
                        // For now, let's just use cycle or assume simple status logic is sufficient
                        // But wait, toggleTaskStatus cycles. We need setStatus.
                        // Let's modify toggleTaskStatus logic locally or expose updateTask
                         // Using updateStatus directly would be better.
                         // For this simulation:
                         setEmployeeTasks(prev => ({
                             ...prev,
                             [selectedEmployeeId]: {
                                 ...prev[selectedEmployeeId],
                                 [taskId]: status
                             }
                         }));
                    }
                    e.currentTarget.classList.remove('bg-gray-100');
                };

                return (
                    <div className="grid grid-cols-1 md:grid-cols-3 gap-6 h-full overflow-x-auto pb-4">
                        {columns.map(col => (
                            <div 
                                key={col.id} 
                                className={`rounded-xl border-2 ${col.border} ${col.bg} flex flex-col h-full min-h-[500px] transition-colors`}
                                onDragOver={(e) => { e.preventDefault(); e.currentTarget.classList.add('bg-gray-100'); }}
                                onDragLeave={(e) => e.currentTarget.classList.remove('bg-gray-100')}
                                onDrop={(e) => handleDrop(e, col.id)}
                            >
                                <div className="p-4 border-b bg-white/50 backdrop-blur rounded-t-xl flex justify-between items-center sticky top-0 z-10">
                                    <h3 className="font-bold text-gray-700 flex items-center gap-2">{col.icon} {col.title}</h3>
                                    <span className="bg-white px-2 py-1 rounded-full text-xs font-bold shadow-sm">{filteredTasks.filter(t => t.status === col.id).length}</span>
                                </div>
                                <div className="p-4 flex-1 overflow-y-auto space-y-3 custom-scrollbar">
                                    {filteredTasks.filter(t => t.status === col.id).map(task => <TaskCard key={task.id} task={task} onUpdate={updateTask} onDelete={deleteTask} onOpenResourcePanel={(taskId) => setResourcePanelTaskId(taskId)} />)}
                                </div>
                            </div>
                        ))}
                    </div>
                );
            };

            /**
             * GanttView - Vue Gantt (diagramme de Gantt)
             * --------------------------------------------
             * Affiche les phases et taches sur une timeline horizontale.
             * 
             * CALCULS:
             * - totalDuration: Duree totale du parcours (max des phases)
             * - Position des phases: Basee sur startOffset et duration
             * - Position des taches: Basee sur dayOffset
             * 
             * AFFICHAGE:
             * - Barres de phase: Couleur de la phase, opacite 30%
             * - Points de tache: Positionnes selon dayOffset
             * - Timeline: J+0, J+10, J+20, J+30
             */
            /**
             * GanttView - Vue Gantt (diagramme de Gantt)
             * --------------------------------------------
             * Affiche les phases et taches sur une timeline horizontale.
             * 
             * CALCULS:
             * - totalDuration: Duree totale du parcours (max des phases)
             * - Position des phases: Basee sur startOffset et duration
             * - Position des taches: Basee sur dayOffset
             * 
             * AFFICHAGE:
             * - Barres de phase: Couleur de la phase, opacite 30%
             * - Points de tache: Positionnes selon dayOffset
             * - Timeline: J+0, J+10, J+20, J+30
             */
            const GanttView = () => {
                if (!selectedEmployee) return null;
                const startDate = new Date(selectedEmployee.startDate);
                const totalDuration = Math.max(...phases.map(p => p.startOffset + p.duration), 30); // Min 30 days
                
                return (
                    <div className="bg-white rounded-xl shadow-lg overflow-x-auto border">
                        <div className="min-w-[800px] p-6">
                            {/* Timeline Header */}
                            <div className="flex border-b pb-2 mb-4">
                                <div className="w-48 font-bold text-gray-700">Tache / Phase</div>
                                <div className="flex-1 relative h-6">
                                    {[0, 10, 20, 30].map(d => (
                                        <div key={d} className="absolute text-xs text-gray-400" style={{ left: `${(d / totalDuration) * 100}%` }}>J+{d}</div>
                                    ))}
                                </div>
                            </div>
                            
                            {/* Phases Rows */}
                            {phases.map(phase => (
                                <div key={phase.id} className="mb-6">
                                    <div className="flex items-center mb-2">
                                        <div className="w-48 font-bold text-gray-800 text-sm truncate pr-2">{phase.name}</div>
                                        <div className="flex-1 relative h-8 bg-gray-50 rounded-full overflow-hidden">
                                            <div 
                                                className="absolute h-full opacity-30 rounded-full" 
                                                style={{ 
                                                    left: `${(phase.startOffset / totalDuration) * 100}%`, 
                                                    width: `${(phase.duration / totalDuration) * 100}%`,
                                                    backgroundColor: phase.color
                                                }}
                                            ></div>
                                            <div className="absolute top-1/2 -translate-y-1/2 text-xs font-bold text-gray-600 ml-2" style={{ left: `${(phase.startOffset / totalDuration) * 100}%` }}>
                                                {phase.startDate} - {phase.endDate}
                                            </div>
                                        </div>
                                    </div>
                                    
                                    {/* Tasks Rows */}
                                    {filteredTasks.filter(t => t.phaseId === phase.id).map(task => {
                                        const taskStart = task.dayOffset;
                                        const taskDuration = 1; // Default 1 day visual
                                        return (
                                            <div key={task.id} className="flex items-center mb-1 hover:bg-gray-50 rounded">
                                                <div className="w-48 text-xs text-gray-600 truncate pl-4 pr-2">{task.title}</div>
                                                <div className="flex-1 relative h-5">
                                                    <div 
                                                        className={`absolute h-3 top-1 rounded-full ${statusColors[task.status]}`} 
                                                        style={{ 
                                                            left: `${(taskStart / totalDuration) * 100}%`,
                                                            width: `${Math.max((taskDuration / totalDuration) * 100, 1)}%`, // Min width
                                                            minWidth: '8px'
                                                        }}
                                                    ></div>
                                                </div>
                                            </div>
                                        );
                                    })}
                                </div>
                            ))}
                        </div>
                    </div>
                );
            };

            return (
                <div className="min-h-screen relative">
                    {/* Login Screen Overlay */}
                    {!isAuthenticated && <LoginScreen employees={employees} onLogin={(id) => { 
                        setSelectedEmployeeId(id); 
                        setIsAuthenticated(true);
                        // Force re-render to hide login screen
                        setTimeout(() => {
                            // Ensure login screen is hidden
                            const loginScreen = document.querySelector('.fixed.inset-0.z-\\[100\\]');
                            if (loginScreen && isAuthenticated) {
                                loginScreen.style.display = 'none';
                            }
                        }, 100);
                    }} />}
                    
                    {/* Email Prompt Modal */}
                    <EmailPromptModal 
                        isOpen={showEmailPrompt}
                        onClose={() => {
                            setShowEmailPrompt(false);
                            setEmailPromptCallback(null);
                        }}
                        onConfirm={(email) => {
                            if (emailPromptCallback) {
                                emailPromptCallback(email);
                                setEmailPromptCallback(null);
                            }
                            setShowEmailPrompt(false);
                        }}
                    />
                    
                    {/* Save Indicator (Bottom Left) */}
                    <div className={`fixed bottom-6 left-6 bg-gray-900 text-white px-4 py-2 rounded-full shadow-lg z-50 transition-all duration-300 flex items-center gap-2 ${saveIndicator.visible ? 'opacity-100 translate-y-0' : 'opacity-0 translate-y-4'}`}>
                        <span className="w-2 h-2 bg-green-500 rounded-full animate-pulse"></span>
                        <span className="text-sm font-medium">{saveIndicator.message}</span>
                    </div>

                    {/* Toast Notification */}
                    {/* Toast Notification Top Center */}
                    {notification && (
                        <div className={`fixed top-6 left-1/2 -translate-x-1/2 z-[200] px-6 py-3 rounded-xl shadow-2xl flex items-center gap-3 animate-fade-in-down transition-all duration-300 ${notification.type === 'error' ? 'bg-red-500 text-white' : 'bg-gray-900 text-white'}`}>
                            {notification.type === 'error' ? <Icons.AlertCircle /> : <Icons.CheckCircle />}
                            <span className="font-bold tracking-wide">{notification.message}</span>
                            <button onClick={() => setNotification(null)} className="ml-2 opacity-60 hover:opacity-100"><Icons.X /></button>
                        </div>
                    )}
                    
                    {/* Header avec selecteur d'employe */}
                    <div className="bg-white/90 backdrop-blur-md sticky top-0 z-30 border-b border-gray-100 shadow-sm">
                        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
                            <div className="flex justify-between items-center h-28">
                                {/* Logo / Title */}
                                <div className="flex items-center gap-5">
                                    <div className="w-16 h-16 bg-gradient-to-br from-blue-600 to-indigo-600 rounded-2xl flex items-center justify-center text-white shadow-lg text-2xl">
                                        <Icons.Layers />
                                    </div>
                                    <div>
                                        <h1 className="text-xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-blue-600 to-indigo-600">
                                            Portail Emma RH
                                        </h1>
                                        <p className="text-xs text-gray-500">Module JSLAI - Accueil et integration pour nouvelle ressource</p>
                                    </div>
                                </div>

                                {/* Controls & Progress */}
                                <div className="flex items-center gap-6">
                                     {/* Progress Thermometer */}
                                     <div className="hidden lg:flex flex-col items-end">
                                          <div className="flex items-center gap-2 mb-1">
                                               <span className="text-sm font-bold text-gray-700">{stats.progress}%</span>
                                               <div className="w-32 h-2.5 bg-gray-100 rounded-full overflow-hidden border">
                                                    <div className="h-full bg-gradient-to-r from-blue-400 to-green-500 transaction-all duration-1000 ease-out" style={{ width: `${stats.progress}%` }}></div>
                                               </div>
                                          </div>
                                          <p className="text-xs text-blue-600 font-medium animate-pulse">
                                              {stats.progress === 100 ? " Felicitations, integration terminee !" : 
                                               stats.progress > 75 ? " Presque fini, lachez pas !" :
                                               stats.progress > 50 ? " Super, on a depasse la moitie !" :
                                               stats.progress > 25 ? " Bon debut, continuez comme ca !" :
                                               " Bienvenue, commencons l'aventure !"}
                                          </p>
                                     </div>

                                    <div className="hidden md:flex items-center gap-4 bg-white pl-3 pr-5 py-2 rounded-full border shadow-sm">
                                        <div className="w-14 h-14 rounded-full overflow-hidden border-2 border-gray-100">
                                            {selectedEmployee.avatarUrl ? <img src={selectedEmployee.avatarUrl} className="w-full h-full object-cover" /> : <span className="flex items-center justify-center h-full text-sm font-bold bg-blue-50 text-blue-600">{selectedEmployee.name?.charAt(0)}</span>}
                                        </div>
                                        <div className="flex flex-col">
                                             <span className="text-[10px] text-gray-400 font-medium leading-tight uppercase tracking-wider">Bonjour,</span>
                                             <select 
                                                value={selectedEmployeeId} 
                                                onChange={(e) => setSelectedEmployeeId(parseInt(e.target.value))}
                                                className="bg-transparent border-none p-0 text-sm font-bold text-gray-800 outline-none cursor-pointer focus:ring-0 leading-tight hover:text-blue-600 transition-colors w-full"
                                            >
                                                {employees.map(e => <option key={e.id} value={e.id}>{e.name}</option>)}
                                            </select>
                                        </div>
                                    </div>

                                    <button onClick={() => setShowAdmin(true)} className="w-10 h-10 flex items-center justify-center text-gray-400 hover:text-blue-600 hover:bg-white hover:shadow-md rounded-full transition-all border border-transparent hover:border-gray-100">
                                        <Icons.Settings />
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>

                    {/* Main Content */}
                    <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
                        <div className="flex flex-col md:flex-row md:items-center justify-between gap-4 mb-8">
                            <div>
                                <h1 className="text-3xl font-extrabold text-gray-900">Tableau de Bord</h1>
                                <p className="text-gray-500 mt-1">Gerez le parcours d'integration de vos employes</p>
                            </div>
                            <div className="flex items-center gap-3">
                                <div className="bg-white px-4 py-2 rounded-lg border shadow-sm text-sm font-bold text-gray-600">
                                     2026
                                </div>
                            </div>
                        </div>

                        {/* Stats Cards */}
                        <div className={`collapsible-content ${showStats ? '' : 'collapsed'}`} style={{ maxHeight: showStats ? '200px' : '0' }}>
                            <div className="grid grid-cols-1 md:grid-cols-4 gap-6 mb-8 mt-2">
                                <div className="bg-white rounded-xl shadow-lg p-4 border-2 flex items-center gap-3">
                                    <div className="w-12 h-12 rounded-full bg-gray-100 flex items-center justify-center text-xl"></div>
                                    <div><div className="text-2xl font-bold">{stats.total}</div><div className="text-sm text-gray-600">Total</div></div>
                                </div>
                                <div className="bg-white rounded-xl shadow-lg p-4 border-2 border-green-200 flex items-center gap-3">
                                    <div className="w-12 h-12 rounded-full bg-green-100 flex items-center justify-center text-xl"></div>
                                    <div><div className="text-2xl font-bold text-green-600">{stats.completed}</div><div className="text-sm text-gray-600">Terminees</div></div>
                                </div>
                                <div className="bg-white rounded-xl shadow-lg p-4 border-2 border-blue-200 flex items-center gap-3">
                                    <div className="w-12 h-12 rounded-full bg-blue-100 flex items-center justify-center text-xl"></div>
                                    <div><div className="text-2xl font-bold text-blue-600">{stats.inProgress}</div><div className="text-sm text-gray-600">En cours</div></div>
                                </div>
                                 <div className="bg-white rounded-xl shadow-lg p-4 border-2 border-yellow-200 flex items-center gap-3">
                                    <div className="w-12 h-12 rounded-full bg-yellow-100 flex items-center justify-center text-xl"></div>
                                    <div><div className="text-2xl font-bold text-yellow-600">{stats.pending}</div><div className="text-sm text-gray-600">A faire</div></div>
                                </div>
                            </div>
                        </div>
                        
                        {/* Toolbar */}
                        <div className="bg-white rounded-xl shadow-lg p-4 mb-6 border-2 flex flex-wrap gap-4 items-center">
                            <div className="relative flex-1 min-w-[200px]">
                                <Icons.Search className="absolute left-3 top-1/2 -translate-y-1/2 text-gray-400" />
                                <input 
                                    type="text" 
                                    placeholder="Rechercher une tache..." 
                                    value={searchTerm}
                                    onChange={(e) => setSearchTerm(e.target.value)}
                                    className="w-full pl-10 pr-4 py-2 bg-gray-50 border rounded-lg focus:ring-2 focus:ring-blue-500 outline-none" 
                                />
                            </div>
                            <div className="flex items-center gap-2 overflow-x-auto pb-1 md:pb-0">
                                <button 
                                    onClick={() => setShowUrgent(!showUrgent)}
                                    className={`px-3 py-1.5 rounded-lg text-sm font-bold flex items-center gap-1 transition-all ${showUrgent ? 'bg-red-100 text-red-600 border border-red-200 shadow-inner' : 'bg-white border border-gray-200 text-gray-400 hover:border-red-200 hover:text-red-400'}`}
                                >
                                     Urgent
                                </button>
                                <div className="h-6 w-px bg-gray-300 mx-1"></div>
                                {['all', 'pending', 'inProgress', 'completed'].map(status => (
                                    <button 
                                        key={status}
                                        onClick={() => setFilterStatus(status)}
                                        className={`px-3 py-1.5 rounded-lg text-sm font-medium whitespace-nowrap transition-colors ${filterStatus === status ? 'bg-blue-600 text-white shadow-md' : 'bg-gray-100 text-gray-600 hover:bg-gray-200'}`}
                                    >
                                        {status === 'all' ? 'Tout' : status === 'pending' ? 'A faire' : status === 'inProgress' ? 'En cours' : 'Termine'}
                                    </button>
                                ))}
                            </div>
                            <button onClick={() => setShowStats(!showStats)} className="p-2 text-gray-500 hover:bg-gray-100 rounded-lg" title="Afficher/Masquer stats">
                                 Apercu
                            </button>
                            
                            <div className="h-6 w-px bg-gray-300 mx-2"></div>

                            <button onClick={() => {
                                try {
                                    if (typeof window.generateEmailHTML !== 'function') {
                                        showNotification(' Le generateur d\'email n\'est pas encore charge. Attendez quelques secondes et reessayez.', 'error');
                                        console.error('window.generateEmailHTML is not a function');
                                        return;
                                    }
                                    const html = window.generateEmailHTML(selectedEmployee, phases, filteredTasks, resources);
                                    if (!html) {
                                        showNotification('Erreur: Impossible de generer l\'email. Verifiez les donnees.', 'error');
                                        return;
                                    }
                                    setEmailPreviewContent(html);
                                    setShowEmailPreview(true);
                                } catch (error) {
                                    console.error('Erreur generation apercu:', error);
                                    showNotification(`Erreur: ${error.message || 'Impossible de generer l\'apercu'}`, 'error');
                                }
                            }} className="p-2 text-blue-600 hover:bg-blue-50 rounded-lg flex items-center gap-2 transition-colors" title="Apercu de l'email">
                                <Icons.Eye /> <span className="hidden md:inline">Apercu Email</span>
                            </button>

                            <button onClick={async () => {
                                try {
                                    if (typeof window.generateEmailHTML !== 'function') {
                                        showNotification(' Le generateur d\'email n\'est pas encore charge. Attendez quelques secondes et reessayez.', 'error');
                                        console.error('window.generateEmailHTML is not a function');
                                        return;
                                    }
                                    const html = window.generateEmailHTML(selectedEmployee, phases, filteredTasks, resources);
                                    if (!html) {
                                        showNotification('Erreur: Impossible de generer l\'email. Verifiez les donnees.', 'error');
                                        return;
                                    }
                                    const blob = new Blob([html], { type: 'text/html' });
                                    const item = new ClipboardItem({ 'text/html': blob });
                                    await navigator.clipboard.write([item]);
                                    showNotification('Email copie dans le presse-papier ! Collez-le dans Outlook/Gmail.', 'success');
                                } catch (err) {
                                    console.error('Erreur copie:', err);
                                    showNotification('Erreur lors de la copie. Utilisez "Apercu" et copiez manuellement.', 'error');
                                }
                            }} className="p-2 text-indigo-600 hover:bg-indigo-50 rounded-lg flex items-center gap-2 transition-colors" title="Copier pour Outlook/Gmail">
                                <Icons.Send /> <span className="hidden md:inline">Copier l'email</span>
                            </button>

                            <button onClick={() => {
                                // Utiliser la fonction globale ou locale
                                const sendFn = window.sendEmailViaResend || sendEmailViaResend;
                                sendFn(selectedEmployee, phases, filteredTasks, resources, showNotification);
                            }} className="p-2 text-green-600 hover:bg-green-50 rounded-lg flex items-center gap-2 transition-colors" title="Envoyer via Resend">
                                <Icons.Send /> <span className="font-bold">Envoyer (Resend)</span>
                            </button>
                        </div>

                        {/* View Switcher Controls */}
                        <div className="flex flex-col items-center justify-center mb-8 gap-2">
                             <p className="text-sm font-bold text-blue-600 animate-bounce"> Choisissez votre vue</p>
                             <div className="bg-white p-2 rounded-xl shadow-xl border-2 border-blue-100 inline-flex ring-4 ring-blue-50 transform hover:scale-105 transition-all duration-300">
                                <button onClick={() => setViewMode('list')} className={`px-4 py-2 rounded-md flex items-center gap-2 text-sm font-medium transition-colors ${viewMode === 'list' ? 'bg-blue-50 text-blue-600' : 'text-gray-500 hover:bg-gray-50'}`}>
                                    <Icons.List /> Liste
                                </button>
                                <button onClick={() => setViewMode('kanban')} className={`px-4 py-2 rounded-md flex items-center gap-2 text-sm font-medium transition-colors ${viewMode === 'kanban' ? 'bg-blue-50 text-blue-600' : 'text-gray-500 hover:bg-gray-50'}`}>
                                    <Icons.Columns /> Kanban
                                </button>
                                <button onClick={() => setViewMode('gantt')} className={`px-4 py-2 rounded-md flex items-center gap-2 text-sm font-medium transition-colors ${viewMode === 'gantt' ? 'bg-blue-50 text-blue-600' : 'text-gray-500 hover:bg-gray-50'}`}>
                                    <Icons.Activity /> Gantt
                                </button>
                             </div>
                        </div>

                        {/* VIEW CONTENT RENDER */}
                        {viewMode === 'list' && (
                            <div className="space-y-6">
                                {phases.map((phase) => {
                                    const phaseTasks = filteredTasks.filter(t => t.phaseId === phase.id);
                                    const completed = phaseTasks.filter(t => t.status === 'completed').length;
                                    const progress = phaseTasks.length > 0 ? Math.round((completed / phaseTasks.length) * 100) : 0;
                                    const isCollapsed = collapsedPhases[phase.id];

                                    return (
                                        <div 
                                            key={phase.id} 
                                            className={`bg-white rounded-xl shadow-sm border transition-all duration-300`}
                                            onDragOver={(e) => {
                                                e.preventDefault();
                                                e.currentTarget.classList.add('drop-zone');
                                            }}
                                            onDragLeave={(e) => {
                                                e.currentTarget.classList.remove('drop-zone');
                                            }}
                                            onDrop={(e) => {
                                                e.preventDefault();
                                                e.currentTarget.classList.remove('drop-zone');
                                                const taskId = e.dataTransfer.getData('taskId');
                                                if (taskId) updateTask(taskId, 'phaseId', phase.id);
                                            }}
                                        >
                                            <div 
                                                className="p-4 border-b flex items-center justify-between cursor-pointer hover:bg-gray-50 transition-colors rounded-t-xl"
                                                onClick={() => togglePhaseCollapse(phase.id)}
                                                style={{ borderLeft: `6px solid ${phase.color}` }}
                                            >
                                                <div className="flex-1">
                                                    <div className="flex items-center gap-2 mb-1">
                                                        <span className={`transform transition-transform duration-200 ${isCollapsed ? '-rotate-90' : ''}`}>
                                                            <Icons.ChevronDown />
                                                        </span>
                                                        <h3 className="text-lg font-bold text-gray-800">{phase.name}</h3>
                                                        {progress === 100 && <span className="text-green-500"><Icons.CheckCircle /></span>}
                                                    </div>
                                                    <div className="flex flex-wrap items-center gap-4 text-sm text-gray-500 ml-6" onClick={(e) => e.stopPropagation()}>
                                                        <div className="flex items-center gap-1">
                                                            <span className="text-[10px] font-bold text-gray-400 uppercase">Debut :</span>
                                                            <DatePicker
                                                                value={phase.startDate}
                                                                onChange={(dateStr) => {
                                                                    // Calculate offset relative to employee start date
                                                                    const emp = selectedEmployee || employees[0];
                                                                    const empStart = TaskManager.ensureMinDate2026(emp?.startDate);
                                                                    const newStart = new Date(dateStr);
                                                                    const diffDays = Math.round((newStart - empStart) / (1000 * 60 * 60 * 24));
                                                                    updatePhaseDirect(phase.id, 'startOffset', diffDays);
                                                                }}
                                                                placeholder="Date debut"
                                                                className="bg-transparent border-b border-dashed border-gray-300 hover:border-blue-500 focus:border-blue-500 outline-none"
                                                                min="2026-01-01"
                                                                showIcon={false}
                                                            />
                                                        </div>
                                                        <span>-></span>
                                                        <div className="flex items-center gap-1">
                                                            <span className="text-[10px] font-bold text-gray-400 uppercase">Fin :</span>
                                                            <DatePicker
                                                                value={phase.endDate}
                                                                onChange={(dateStr) => {
                                                                    // Calculate duration from start date
                                                                    const startDate = new Date(phase.startDate);
                                                                    const endDate = new Date(dateStr);
                                                                    const duration = Math.round((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1;
                                                                    if (duration > 0) {
                                                                        updatePhaseDirect(phase.id, 'duration', duration);
                                                                    }
                                                                }}
                                                                placeholder="Date fin"
                                                                className="bg-transparent border-b border-dashed border-gray-300 hover:border-blue-500 focus:border-blue-500 outline-none text-gray-400"
                                                                min={phase.startDate}
                                                                showIcon={false}
                                                            />
                                                        </div>
                                                        <span>({phase.duration} jours)</span>
                                                    </div>
                                                </div>
                                                
                                                <div className="flex items-center gap-4">
                                                    {/* Progress bar */}
                                                    <div className="w-32 h-2 bg-gray-200 rounded-full overflow-hidden hidden sm:block">
                                                        <div className="h-full rounded-full transition-all" style={{ width: `${progress}%`, backgroundColor: phase.color }}></div>
                                                    </div>
                                                    <div className="text-right min-w-[60px]">
                                                        <div className="text-xl font-bold" style={{ color: phase.color }}>{completed}/{phaseTasks.length}</div>
                                                    </div>
                                                </div>
                                            </div>
                                            
                                            <div className={`collapsible-content bg-gray-50 ${isCollapsed ? 'collapsed' : ''}`} style={{ maxHeight: isCollapsed ? '0' : '2000px', padding: isCollapsed ? '0' : '1rem' }}>
                                                {phaseTasks.length > 0 ? phaseTasks.map(task => <TaskCard key={task.id} task={task} onUpdate={updateTask} onDelete={deleteTask} onOpenResourcePanel={(taskId) => setResourcePanelTaskId(taskId)} />) : (
                                                    <div className="flex flex-col items-center justify-center py-8 text-gray-400">
                                                        <div className="w-16 h-16 bg-gray-100 rounded-full flex items-center justify-center mb-2 text-2xl"></div>
                                                        <p className="font-medium">Aucune tache pour le moment</p>
                                                        <p className="text-xs">Profitez-en pour prendre un cafe </p>
                                                    </div>
                                                )}
                                                <button onClick={(e) => { e.stopPropagation(); addTask(phase.id); }} className="w-full mt-2 py-2 border-2 border-dashed border-gray-300 rounded-lg text-gray-500 hover:border-blue-400 hover:text-blue-500 transition-colors flex items-center justify-center gap-2 add-btn">
                                                    <Icons.Plus /> Ajouter une tache
                                                </button>
                                            </div>
                                        </div>
                                    );
                                })}
                            </div>
                        )}

                        {viewMode === 'kanban' && <KanbanView />}
                        {viewMode === 'gantt' && <GanttView />}
                    </div>

                    {/* Footer */}
                    <div className="bg-gray-900 text-white py-6 mt-12">
                        <div className="max-w-7xl mx-auto px-6 text-center">
                            <p className="opacity-50 text-sm"> 2026 - Propulse par JSLAI - Tous droits reserves.</p>
                        </div>
                    </div>

                    {/* Email Preview Modal */}
                    {showEmailPreview && (
                        <div className="fixed inset-0 bg-black/80 backdrop-blur-sm z-50 flex items-center justify-center p-4 animate-fade-in">
                            <div className="bg-white rounded-2xl w-full max-w-4xl max-h-[90vh] overflow-y-auto shadow-2xl relative">
                                <button onClick={() => setShowEmailPreview(false)} className="absolute top-4 right-4 p-2 hover:bg-gray-100 rounded-full transition-colors"><Icons.X /></button>
                                <div className="p-8">
                                    <h2 className="text-2xl font-bold mb-6 text-gray-800 flex items-center gap-3">
                                        <div className="bg-blue-600 text-white p-2 rounded-lg"><Icons.Eye /></div>
                                        Apercu de l'email
                                    </h2>
                                    <div className="border-2 border-gray-100 rounded-xl p-6 bg-gray-50 overflow-auto max-h-[600px] email-preview" dangerouslySetInnerHTML={{ __html: emailPreviewContent }}></div>
                                    <div className="mt-6 flex justify-end gap-3">
                                        <button onClick={() => setShowEmailPreview(false)} className="px-4 py-2 text-gray-500 hover:bg-gray-100 rounded-lg">Fermer</button>
                                        <button onClick={async () => {
                                            try {
                                                // Try modern ClipboardItem API first (for HTML)
                                                if (typeof ClipboardItem !== 'undefined') {
                                                    const blob = new Blob([emailPreviewContent], { type: 'text/html' });
                                                    const item = new ClipboardItem({ 'text/html': blob });
                                                    await navigator.clipboard.write([item]);
                                                    showNotification('Email copie !', 'success');
                                                    setShowEmailPreview(false);
                                                } else {
                                                    // Fallback: copy as plain text
                                                    await navigator.clipboard.writeText(emailPreviewContent);
                                                    showNotification('Email copie (texte). Format HTML dans l\'apercu.', 'success');
                                                    setShowEmailPreview(false);
                                                }
                                            } catch (err) {
                                                console.error('Erreur copie:', err);
                                                // Final fallback: create temporary textarea
                                                try {
                                                    const textarea = document.createElement('textarea');
                                                    textarea.value = emailPreviewContent;
                                                    textarea.style.position = 'fixed';
                                                    textarea.style.opacity = '0';
                                                    document.body.appendChild(textarea);
                                                    textarea.select();
                                                    document.execCommand('copy');
                                                    document.body.removeChild(textarea);
                                                    showNotification('Email copie (methode alternative)', 'success');
                                                    setShowEmailPreview(false);
                                                } catch (fallbackErr) {
                                                    showNotification('Erreur copie. Selectionnez et copiez manuellement.', 'error');
                                                }
                                            }
                                        }} className="px-6 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 font-bold flex items-center gap-2">
                                            <Icons.Send /> Copier le contenu
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Admin Panel Overlay */}
                    {showAdmin && (
                        <AdminPanel 
                            employees={employees}
                            setEmployees={setEmployees}
                            resources={resources}
                            setResources={setResources}
                            phaseTemplates={phaseTemplates}
                            setPhaseTemplates={setPhaseTemplates}
                            taskTemplates={taskTemplates}
                            setTaskTemplates={setTaskTemplates}
                            supabase={supabase}
                            useSupabase={useSupabase}
                            showNotification={showNotification}
                            uploadAvatar={uploadAvatar}
                            onClose={() => setShowAdmin(false)}
                            selectedEmployee={selectedEmployee}
                        />
                    )}

                    {/* Chatbot Emma */}
                    <EmmaChatbot employee={selectedEmployee} tasks={tasks} phases={phases} resources={resources} />
                    
                    {/* Panneau lateral droit pour assignation de responsables - RENDU UNE SEULE FOIS AU NIVEAU SUPERIEUR */}
                    {resourcePanelTaskId && (() => {
                        // Trouver la tache actuelle dans tasks (qui se met a jour automatiquement)
                        const selectedTask = tasks.find(t => t.id === resourcePanelTaskId);
                        if (!selectedTask) {
                            // Si la tache n'existe plus, fermer le panneau
                            setTimeout(() => setResourcePanelTaskId(null), 0);
                            return null;
                        }
                        const assignedResources = resources.filter(r => (selectedTask.assignedTo || []).includes(r.id));
                        
                        return (
                            <div style={{ position: 'fixed', inset: 0, zIndex: 10000, pointerEvents: 'none' }}>
                                {/* Overlay semi-transparent pour fermer en cliquant a l'exterieur */}
                                <div 
                                    className="fixed inset-0 bg-black/20 backdrop-blur-sm"
                                    style={{ pointerEvents: 'auto' }}
                                    onClick={() => setResourcePanelTaskId(null)}
                                />
                                {/* Panneau lateral droit - style slide-in */}
                                <div 
                                    className="fixed right-0 top-0 h-full w-80 bg-white flex flex-col"
                                    style={{
                                        boxShadow: '-4px 0 20px rgba(0, 0, 0, 0.15)',
                                        pointerEvents: 'auto',
                                        zIndex: 10001
                                    }}
                                    onClick={(e) => e.stopPropagation()}
                                >
                                    {/* Header fixe */}
                                    <div className="px-4 py-3 bg-gradient-to-r from-blue-600 to-indigo-600 text-white flex items-center justify-between flex-shrink-0">
                                        <div className="flex items-center gap-2">
                                            <Icons.Users className="w-5 h-5" />
                                            <div>
                                                <div className="text-sm font-bold">Assigner responsables</div>
                                                <div className="text-xs text-blue-100">{selectedTask.title}</div>
                                            </div>
                                        </div>
                                        <button 
                                            onClick={() => setResourcePanelTaskId(null)} 
                                            className="text-white/80 hover:text-white hover:bg-white/20 p-1.5 rounded-lg transition-colors"
                                            title="Fermer"
                                        >
                                            <Icons.X className="w-5 h-5" />
                                        </button>
                                    </div>
                                    
                                    {/* Liste scrollable */}
                                    <div className="flex-1 overflow-y-auto p-4 bg-gray-50">
                                        <div className="space-y-2">
                                            {resources.map(r => {
                                                const isSelected = (selectedTask.assignedTo || []).includes(r.id);
                                                return (
                                                    <div 
                                                        key={r.id} 
                                                        onClick={async (e) => {
                                                            e.stopPropagation();
                                                            const current = selectedTask.assignedTo || [];
                                                            const updated = current.includes(r.id) 
                                                                ? current.filter(id => id !== r.id)
                                                                : [...current, r.id];
                                                            
                                                            // Utiliser updateTask pour mettre a jour l'UI et la DB
                                                            await updateTask(selectedTask.id, 'assignedTo', updated);
                                                        }} 
                                                        className={`flex items-center gap-3 p-3 rounded-lg cursor-pointer transition-all ${
                                                            isSelected
                                                                ? 'bg-blue-50 border-2 border-blue-400 shadow-sm' 
                                                                : 'bg-white border border-gray-200 hover:border-blue-300 hover:shadow-sm'
                                                        }`}
                                                    >
                                                        <div className={`w-10 h-10 rounded-full flex items-center justify-center text-white text-sm font-bold flex-shrink-0 border-2 ${
                                                            isSelected ? 'border-blue-500 shadow-md' : 'border-gray-300'
                                                        }`} style={{ backgroundColor: r.color }}>
                                                            {isSelected && <Icons.CheckCircle className="w-5 h-5" />}
                                                            {!isSelected && <span>{r.name.charAt(0)}</span>}
                                                        </div>
                                                        <div className="flex-1 min-w-0">
                                                            <div className="text-sm font-semibold text-gray-900">{r.name}</div>
                                                            <div className="text-xs text-gray-500">{r.role}</div>
                                                        </div>
                                                        {isSelected && (
                                                            <Icons.CheckCircle className="w-5 h-5 text-blue-600 flex-shrink-0" />
                                                        )}
                                                    </div>
                                                );
                                            })}
                                        </div>
                                    </div>
                                    
                                    {/* Footer fixe avec resume */}
                                    {assignedResources.length > 0 && (
                                        <div className="px-4 py-3 bg-white border-t border-gray-200 flex-shrink-0">
                                            <div className="text-xs font-bold text-gray-500 uppercase mb-2">Actuellement assigne(s) :</div>
                                            <div className="flex flex-wrap gap-2">
                                                {assignedResources.map(r => (
                                                    <span key={r.id} className="px-3 py-1.5 rounded-full text-xs font-medium flex items-center gap-1.5 shadow-sm" style={{ backgroundColor: r.color + '15', border: `1px solid ${r.color}40`, color: r.color }}>
                                                        <span className="w-2.5 h-2.5 rounded-full" style={{ backgroundColor: r.color }}></span>
                                                        {r.name}
                                                    </span>
                                                ))}
                                            </div>
                                        </div>
                                    )}
                                </div>
                            </div>
                        );
                    })()}
                </div>
            );
        };

        // Hide loading screen OPTIMISE - Cache des que React est pret, pas apres le render complet
        const hideLoadingScreen = () => {
            const loadingScreen = document.getElementById('loading-screen');
            const loadingBg = document.getElementById('loading-bg');
            
            // Charger l'image de fond en arriere-plan (non-bloquant)
            if (loadingBg) {
                loadingBg.style.opacity = '1';
            }
            
            // Cacher l'ecran de chargement IMMEDIATEMENT apres le premier render
            if (loadingScreen) {
                // Utiliser requestAnimationFrame pour ne pas bloquer le rendu
                requestAnimationFrame(() => {
                    loadingScreen.style.transition = 'opacity 0.3s ease-out';
                    loadingScreen.style.opacity = '0';
                    setTimeout(() => {
                        loadingScreen.remove();
                        console.log(' Ecran de chargement masque');
                    }, 300);
                });
            }
        };

        // Cacher l'ecran de chargement des que React est disponible (pas apres le render complet)
        if (typeof React !== 'undefined' && typeof ReactDOM !== 'undefined') {
            // React est pret, on peut commencer a cacher l'ecran
            setTimeout(hideLoadingScreen, 100);
        }

        ReactDOM.render(
            <ErrorBoundary>
                <OnboardingPlatform />
            </ErrorBoundary>, 
            document.getElementById('root')
        );
    </script>
</body>
</html>
