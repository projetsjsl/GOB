/**
 * Emma Agent - Syst√®me de Function Calling Intelligent avec Cognitive Scaffolding
 *
 * Architecture:
 * - COGNITIVE SCAFFOLDING LAYER: Analyse d'intention avec Perplexity
 * - ReAct REASONING LAYER: S√©lection intelligente d'outils
 * - TOOL USE LAYER: Ex√©cution parall√®le avec fallbacks
 * - SYNTHESIS LAYER: G√©n√©ration de r√©ponse finale
 */

import fs from 'fs';
import path from 'path';
import { HybridIntentAnalyzer } from '../lib/intent-analyzer.js';

class SmartAgent {
    constructor() {
        this.toolsConfig = this._loadToolsConfig();
        this.usageStats = this._loadUsageStats();
        this.conversationHistory = [];
        this.intentAnalyzer = new HybridIntentAnalyzer();
    }

    /**
     * Point d'entr√©e principal pour Emma
     */
    async processRequest(userMessage, context = {}) {
        try {
            console.log('ü§ñ Emma Agent: Processing request:', userMessage.substring(0, 100) + '...');

            // 0. COGNITIVE SCAFFOLDING: Analyse d'intention avec Perplexity
            const intentData = await this._analyzeIntent(userMessage, context);
            console.log('üß† Intent analysis:', intentData ? intentData.intent : 'fallback to keyword scoring');

            // Si clarification n√©cessaire, retourner imm√©diatement
            if (intentData && intentData.needs_clarification) {
                return this._handleClarification(intentData, userMessage);
            }

            // Enrichir le contexte avec les donn√©es d'intention
            if (intentData) {
                context.intent_data = intentData;
                context.extracted_tickers = intentData.tickers || [];
                context.suggested_tools = intentData.suggested_tools || [];
            }

            // 1. Planification avec scoring (enrichi par l'intent)
            const selectedTools = await this._plan_with_scoring(userMessage, context);
            console.log('üìã Selected tools:', selectedTools.map(t => t.id));

            // 2. Ex√©cution des outils
            const toolResults = await this._execute_all(selectedTools, userMessage, context);
            console.log('‚ö° Tool execution completed');

            // 3. G√©n√©ration de la r√©ponse finale
            const responseData = await this._generate_response(userMessage, toolResults, context, intentData);
            console.log('‚ú® Final response generated');

            // Extraire r√©ponse, validation et mod√®le si objet retourn√©
            let finalResponse = responseData;
            let dataValidation = null;
            let modelUsed = null;
            let modelReason = null;

            if (typeof responseData === 'object' && responseData.response) {
                finalResponse = responseData.response;
                dataValidation = responseData.validation;
                modelUsed = responseData.model;
                modelReason = responseData.model_reason;
            }

            // 4. Mise √† jour de l'historique
            this._updateConversationHistory(userMessage, finalResponse, toolResults);

            // 5. Sauvegarde des statistiques
            this._saveUsageStats();

            // Identifier les outils qui ont √©chou√© ou retourn√© des donn√©es non fiables
            const failedToolsData = toolResults
                .filter(r => !r.success || !r.is_reliable)
                .map(r => ({
                    id: r.tool_id,
                    error: r.error || 'Donn√©es non fiables'
                }));

            const failedTools = failedToolsData.map(t => t.id);

            // Mapping des IDs techniques vers des noms lisibles
            const nameMapping = {
                'fmp-quote': 'Prix actions (FMP)',
                'polygon-stock-price': 'Prix actions (Polygon)',
                'fmp-fundamentals': 'Donn√©es fondamentales (FMP)',
                'fmp-ratios': 'Ratios financiers (FMP)',
                'fmp-key-metrics': 'M√©triques cl√©s (FMP)',
                'fmp-ratings': 'Ratings entreprises (FMP)',
                'fmp-ticker-news': 'Actualit√©s ticker (FMP)',
                'finnhub-news': 'Actualit√©s (Finnhub)',
                'twelve-data-technical': 'Indicateurs techniques',
                'alpha-vantage-ratios': 'Ratios financiers (Alpha Vantage)',
                'yahoo-finance': 'Yahoo Finance',
                'supabase-watchlist': 'Watchlist',
                'team-tickers': 'Tickers √©quipe',
                'economic-calendar': 'Calendrier √©conomique (FMP)',
                'earnings-calendar': 'Calendrier r√©sultats (FMP)',
                'analyst-recommendations': 'Recommandations analystes (FMP)',
                'calculator': 'Calculatrice financi√®re'
            };

            const unavailableSources = failedToolsData.map(toolData => {
                const readableName = nameMapping[toolData.id] || toolData.id;
                return `${readableName} (${toolData.error})`;
            });

            // Calculer score de confiance global
            const intentConfidence = intentData?.confidence || 0.7;
            const dataConfidence = dataValidation?.confidence || 0.7;
            const globalConfidence = (intentConfidence + dataConfidence) / 2;

            return {
                success: true,
                response: finalResponse,
                tools_used: selectedTools.map(t => t.id),
                failed_tools: failedTools,
                unavailable_sources: unavailableSources,
                intent: intentData ? intentData.intent : 'unknown',
                confidence: globalConfidence, // Score de confiance global (0-1)
                intent_confidence: intentConfidence,
                data_confidence: dataConfidence,
                has_sources: dataValidation?.passed || false,
                source_types: dataValidation?.source_types_found || 0,
                output_mode: context.output_mode || 'chat',
                execution_time_ms: Date.now() - (context.start_time || Date.now()),
                conversation_length: this.conversationHistory.length,
                is_reliable: toolResults.every(r => r.is_reliable) && (dataValidation?.passed !== false),
                model: modelUsed || 'unknown',  // Mod√®le utilis√© pour g√©n√©rer la r√©ponse
                model_reason: modelReason || 'Unknown reason'  // Raison du choix du mod√®le
            };

        } catch (error) {
            console.error('‚ùå Emma Agent Error:', error);
            return {
                success: false,
                error: error.message,
                response: "D√©sol√©, j'ai rencontr√© une erreur technique. Veuillez r√©essayer.",
                is_reliable: false
            };
        }
    }

    /**
     * COGNITIVE SCAFFOLDING LAYER
     * Analyse d'intention HYBRIDE (local + LLM) pour optimiser performances et co√ªts
     */
    async _analyzeIntent(userMessage, context) {
        try {
            console.log('üß† Starting HYBRID intent analysis...');

            // Utiliser le HybridIntentAnalyzer
            const intentData = await this.intentAnalyzer.analyze(userMessage, context);

            console.log('‚úÖ Intent analyzed:', intentData);
            console.log(`‚ö° Method: ${intentData.analysis_method}, Time: ${intentData.execution_time_ms}ms`);

            return intentData;

        } catch (error) {
            console.error('‚ùå Intent analysis failed:', error.message);
            // Retombe gracieusement sur le scoring par mots-cl√©s
            return null;
        }
    }


    /**
     * G√®re les clarifications quand l'intention est ambigu√´
     */
    _handleClarification(intentData, userMessage) {
        console.log('üí¨ Clarification needed, returning questions');

        let clarificationResponse = `Pour vous fournir une r√©ponse pr√©cise, j'ai besoin de quelques pr√©cisions :\n\n`;

        // Ajouter les questions de clarification
        intentData.clarification_questions.forEach((question, index) => {
            clarificationResponse += `${index + 1}. ${question}\n`;
        });

        // Ajouter des exemples si disponibles
        if (intentData.user_intent_summary) {
            clarificationResponse += `\nüí° **Contexte d√©tect√©:** ${intentData.user_intent_summary}\n`;
        }

        // Suggestions bas√©es sur l'intent d√©tect√©
        if (intentData.intent === 'stock_analysis' && !intentData.tickers.length) {
            clarificationResponse += `\n**Exemples:**\n`;
            clarificationResponse += `- "Analyse technique de AAPL"\n`;
            clarificationResponse += `- "Fondamentaux de Tesla"\n`;
            clarificationResponse += `- "Actualit√©s Microsoft"\n`;
        }

        return {
            success: true,
            response: clarificationResponse,
            needs_clarification: true,
            intent: intentData.intent,
            confidence: intentData.confidence,
            tools_used: [],
            is_reliable: true
        };
    }

    /**
     * üß† INTELLIGENT COMPLEXITY DETECTION - D√©tecte automatiquement le mode optimal
     * Ajuste outputMode selon la complexit√© et l'intention d√©tect√©es
     */
    _detectComplexity(userMessage, intentData, context) {
        // Indicateurs de complexit√© haute ‚Üí mode expert
        const complexityIndicators = {
            // Mots-cl√©s indiquant analyse approfondie
            deepAnalysisKeywords: ['analyse approfondie', 'analyse compl√®te', 'analyse d√©taill√©e', 'comprehensive',
                'en profondeur', 'exhaustive', 'toutes les donn√©es', 'tous les aspects', 'comparaison d√©taill√©e'],

            // Requ√™tes multi-tickers (> 3)
            multipleTickersThreshold: 3,

            // Intentions complexes n√©cessitant expertise
            complexIntents: ['comprehensive_analysis', 'portfolio_analysis', 'sector_comparison',
                'fundamental_analysis', 'technical_deep_dive'],

            // Longueur de message indiquant d√©tails souhait√©s
            longMessageThreshold: 150, // caract√®res
        };

        let complexityScore = 0;
        let reasons = [];

        // 1. Analyser les mots-cl√©s
        const messageLower = userMessage.toLowerCase();
        if (complexityIndicators.deepAnalysisKeywords.some(keyword => messageLower.includes(keyword))) {
            complexityScore += 3;
            reasons.push('deep analysis keywords');
        }

        // 2. Compter les tickers mentionn√©s
        const tickerCount = intentData?.tickers?.length || 0;
        if (tickerCount >= complexityIndicators.multipleTickersThreshold) {
            complexityScore += 2;
            reasons.push(`${tickerCount} tickers`);
        }

        // 3. V√©rifier l'intention
        if (intentData && complexityIndicators.complexIntents.includes(intentData.intent)) {
            complexityScore += 2;
            reasons.push(`complex intent: ${intentData.intent}`);
        }

        // 4. Longueur du message
        if (userMessage.length > complexityIndicators.longMessageThreshold) {
            complexityScore += 1;
            reasons.push('detailed query');
        }

        // 5. Confiance faible = besoin de plus de contexte/explications
        if (intentData && intentData.confidence < 0.6) {
            complexityScore += 1;
            reasons.push('low confidence, need detail');
        }

        // 6. Mots-cl√©s sp√©cifiques indiquant mode briefing
        const briefingKeywords = ['briefing', 'r√©sum√© quotidien', 'daily', 'newsletter', 'rapport'];
        if (briefingKeywords.some(k => messageLower.includes(k))) {
            console.log(`üß† Detected briefing mode: ${reasons.join(', ')}`);
            return 'briefing';
        }

        // D√©cision bas√©e sur le score
        if (complexityScore >= 4) {
            console.log(`üß† High complexity (${complexityScore}): ${reasons.join(', ')} ‚Üí expert mode`);
            return 'expert';
        } else if (complexityScore >= 2) {
            console.log(`üß† Medium complexity (${complexityScore}): ${reasons.join(', ')} ‚Üí comprehensive mode`);
            return 'comprehensive';
        }

        // Pas de changement de mode
        return null;
    }

    /**
     * SMART ROUTER - S√©lectionne le meilleur mod√®le selon le type de requ√™te
     *
     * Strat√©gie optimis√©e co√ªt/performance:
     * - Perplexity (80%): Donn√©es factuelles avec sources (stock prices, news, fundamentals)
     * - Gemini (15%): Questions conceptuelles/√©ducatives (gratuit)
     * - Claude (5%): R√©daction premium (briefings, lettres clients)
     */
    _selectModel(intentData, outputMode, toolsData) {
        console.log('üéØ SmartRouter: Selecting optimal model...');

        // BRIEFING MODE: Toujours Claude pour qualit√© premium
        if (outputMode === 'briefing') {
            console.log('üìù Briefing detected ‚Üí Using CLAUDE (premium writing)');
            return {
                model: 'claude',
                reason: 'Briefing requires premium writing quality',
                recency: intentData?.recency_filter || 'month'
            };
        }

        // DATA MODE: Perplexity pour extraire donn√©es structur√©es
        if (outputMode === 'data') {
            console.log('üìä Data extraction ‚Üí Using PERPLEXITY (structured data)');
            return {
                model: 'perplexity',
                reason: 'Data extraction requires factual accuracy',
                recency: intentData?.recency_filter || 'month'
            };
        }

        // CHAT MODE: Router intelligemment selon l'intention
        const intent = intentData?.intent || 'unknown';
        const hasTickers = intentData?.tickers && intentData.tickers.length > 0;
        const hasToolData = toolsData && toolsData.length > 0;

        // PERPLEXITY: Requ√™tes factuelles avec sources
        const factualIntents = [
            'stock_price',
            'fundamentals',
            'news',
            'comprehensive_analysis',
            'comparative_analysis',
            'earnings',
            'market_overview',
            'recommendation'
        ];

        if (factualIntents.includes(intent) || hasTickers || hasToolData) {
            console.log(`üíé Factual query (${intent}) ‚Üí Using PERPLEXITY (with sources)`);
            return {
                model: 'perplexity',
                reason: `Factual data required for ${intent}`,
                recency: intentData?.recency_filter || 'day'
            };
        }

        // GEMINI: Questions conceptuelles/√©ducatives (gratuit)
        const conceptualIntents = [
            'portfolio',
            'technical_analysis' // Si pas de ticker sp√©cifique = explication th√©orique
        ];

        if (conceptualIntents.includes(intent) && !hasTickers) {
            console.log(`üí≠ Conceptual query (${intent}) ‚Üí Using GEMINI (free, educational)`);
            return {
                model: 'gemini',
                reason: `Educational/conceptual question about ${intent}`,
                recency: null // Pas de recency pour conceptuel
            };
        }

        // DEFAULT: Perplexity pour s√©curit√©
        console.log('üîÑ Default fallback ‚Üí Using PERPLEXITY');
        return {
            model: 'perplexity',
            reason: 'Default fallback for reliability',
            recency: 'month'
        };
    }

    /**
     * S√©lection intelligente des outils bas√©e sur scoring
     * (Enrichi par l'analyse d'intention si disponible)
     */
    async _plan_with_scoring(userMessage, context) {
        const message = userMessage.toLowerCase();
        const availableTools = this.toolsConfig.tools.filter(tool => tool.enabled);

        // Si intent analysis a sugg√©r√© des outils, leur donner la priorit√©
        const suggestedTools = context.suggested_tools || [];
        const extractedTickers = context.extracted_tickers || context.tickers || [];

        // Scoring des outils
        const scoredTools = availableTools.map(tool => {
            let score = 0;

            // Score de base (priorit√© invers√©e - plus bas = mieux)
            score += (tool.priority * 10);

            // COGNITIVE SCAFFOLDING BOOST: Si l'outil est sugg√©r√© par intent analysis
            if (suggestedTools.includes(tool.id)) {
                const suggestionIndex = suggestedTools.indexOf(tool.id);
                // Plus l'outil est t√¥t dans la liste, plus le boost est fort
                const intentBoost = 100 - (suggestionIndex * 10); // 100, 90, 80, 70, 60
                score -= intentBoost;
                console.log(`üéØ Intent boost for ${tool.id}: -${intentBoost} points`);
            }

            // Score de pertinence contextuelle (enrichi par tickers extraits)
            const relevanceScore = this._calculateRelevanceScore(tool, message, {
                ...context,
                tickers: extractedTickers.length > 0 ? extractedTickers : context.tickers
            });
            score -= relevanceScore;

            // Score de performance historique
            const performanceScore = this._calculatePerformanceScore(tool.id);
            score -= performanceScore;

            // Bonus pour outils r√©cemment utilis√©s avec succ√®s
            const recencyBonus = this._calculateRecencyBonus(tool.id);
            score -= recencyBonus;

            return {
                ...tool,
                calculated_score: score,
                relevance_score: relevanceScore,
                performance_score: performanceScore,
                recency_bonus: recencyBonus,
                intent_boosted: suggestedTools.includes(tool.id)
            };
        });

        // Tri par score (plus bas = mieux)
        scoredTools.sort((a, b) => a.calculated_score - b.calculated_score);

        // S√©lection des meilleurs outils (max 5 simultan√©s)
        const maxTools = Math.min(this.toolsConfig.config.max_concurrent_tools, scoredTools.length);
        const selectedTools = scoredTools.slice(0, maxTools);

        console.log('üéØ Tool scoring results:', selectedTools.map(t => ({
            id: t.id,
            score: t.calculated_score,
            relevance: t.relevance_score,
            performance: t.performance_score
        })));

        return selectedTools;
    }

    /**
     * Calcul du score de pertinence contextuelle
     */
    _calculateRelevanceScore(tool, message, context) {
        let score = 0;
        
        // Mots-cl√©s dans le message
        tool.keywords.forEach(keyword => {
            if (message.includes(keyword.toLowerCase())) {
                score += 20;
            }
        });
        
        // Contexte d'utilisation
        tool.usage_context.forEach(context_word => {
            if (message.includes(context_word.toLowerCase())) {
                score += 15;
            }
        });
        
        // Contexte sp√©cifique (tickers, etc.)
        if (context.tickers && tool.id.includes('ticker')) {
            score += 25;
        }
        
        if (context.news_requested && tool.category === 'news') {
            score += 30;
        }
        
        if (context.calculation_needed && tool.category === 'calculation') {
            score += 35;
        }
        
        return score;
    }

    /**
     * Calcul du score de performance historique
     */
    _calculatePerformanceScore(toolId) {
        const stats = this.usageStats[toolId];
        if (!stats || stats.total_calls === 0) {
            return 10; // Score neutre pour nouveaux outils
        }
        
        // Score bas√© sur le taux de succ√®s
        const successRate = stats.success_rate;
        return Math.round(successRate * 30); // Max 30 points
    }

    /**
     * Bonus pour utilisation r√©cente
     */
    _calculateRecencyBonus(toolId) {
        const stats = this.usageStats[toolId];
        if (!stats || !stats.last_used) {
            return 0;
        }
        
        const hoursSinceLastUse = (Date.now() - new Date(stats.last_used).getTime()) / (1000 * 60 * 60);
        
        // Bonus d√©croissant sur 24h
        if (hoursSinceLastUse < 1) return 15;
        if (hoursSinceLastUse < 6) return 10;
        if (hoursSinceLastUse < 24) return 5;
        return 0;
    }

    /**
     * Ex√©cution parall√®le des outils s√©lectionn√©s
     */
    async _execute_all(selectedTools, userMessage, context) {
        const executionPromises = selectedTools.map(async (tool) => {
            const startTime = Date.now();

            try {
                console.log(`üîß Executing tool: ${tool.id}`);

                // Import dynamique de l'outil
                const toolModule = await import(`../lib/tools/${tool.implementation.file}`);
                const toolInstance = new toolModule.default();

                // Pr√©paration des param√®tres
                const params = this._prepareToolParameters(tool, userMessage, context);

                // Si params est null, skip cet outil (pas de param√®tres valides)
                if (params === null) {
                    console.log(`‚è≠Ô∏è Skipping tool ${tool.id} - no valid parameters`);
                    return {
                        tool_id: tool.id,
                        success: false,
                        error: 'Skipped - no valid parameters',
                        skipped: true,
                        execution_time_ms: 0,
                        is_reliable: false
                    };
                }

                // Ex√©cution avec timeout
                const result = await Promise.race([
                    toolInstance.execute(params, context),
                    new Promise((_, reject) =>
                        setTimeout(() => reject(new Error('Tool timeout')), this.toolsConfig.config.timeout_ms)
                    )
                ]);

                const executionTime = Date.now() - startTime;

                // Mise √† jour des statistiques
                this._updateToolStats(tool.id, true, executionTime);

                return {
                    tool_id: tool.id,
                    success: true,
                    data: result,
                    execution_time_ms: executionTime,
                    is_reliable: result && result.is_reliable !== false
                };

            } catch (error) {
                const executionTime = Date.now() - startTime;
                console.error(`‚ùå Tool ${tool.id} failed:`, error.message);

                // Mise √† jour des statistiques d'erreur
                this._updateToolStats(tool.id, false, executionTime, error.message);

                // Tentative de fallback
                const fallbackResult = await this._tryFallback(tool, userMessage, context);

                return {
                    tool_id: tool.id,
                    success: false,
                    error: error.message,
                    fallback_used: fallbackResult ? fallbackResult.tool_id : null,
                    data: fallbackResult ? fallbackResult.data : null,
                    execution_time_ms: executionTime,
                    is_reliable: fallbackResult ? fallbackResult.is_reliable : false
                };
            }
        });

        const results = await Promise.allSettled(executionPromises);
        return results.map(r => r.status === 'fulfilled' ? r.value : {
            success: false,
            error: r.reason?.message || 'Unknown error',
            is_reliable: false
        });
    }

    /**
     * Tentative de fallback en cas d'√©chec d'outil
     */
    async _tryFallback(failedTool, userMessage, context) {
        if (!failedTool.fallback_tools || failedTool.fallback_tools.length === 0) {
            return null;
        }
        
        for (const fallbackId of failedTool.fallback_tools) {
            try {
                const fallbackTool = this.toolsConfig.tools.find(t => t.id === fallbackId);
                if (!fallbackTool || !fallbackTool.enabled) continue;
                
                console.log(`üîÑ Trying fallback: ${fallbackId}`);
                
                const toolModule = await import(`../lib/tools/${fallbackTool.implementation.file}`);
                const toolInstance = new toolModule.default();
                const params = this._prepareToolParameters(fallbackTool, userMessage, context);
                
                const result = await toolInstance.execute(params, context);
                this._updateToolStats(fallbackId, true, 0);
                
                return {
                    tool_id: fallbackId,
                    data: result,
                    is_reliable: result && result.is_reliable !== false
                };
                
            } catch (error) {
                console.error(`‚ùå Fallback ${fallbackId} also failed:`, error.message);
                continue;
            }
        }
        
        return null;
    }

    /**
     * Pr√©paration des param√®tres pour l'outil
     */
    _prepareToolParameters(tool, userMessage, context) {
        const params = {};

        // Extraction des tickers depuis le contexte et le message
        const extractedTickers = this._extractAllTickers(userMessage, context);

        // Pour les outils qui n√©cessitent un ticker
        if (tool.parameters.ticker) {
            if (extractedTickers && extractedTickers.length > 0) {
                // Si l'outil peut g√©rer plusieurs tickers, passer tous
                // Sinon, prendre le premier (pour compatibilit√©)
                params.ticker = extractedTickers[0];

                // Ajouter tous les tickers au contexte pour que l'outil puisse les utiliser
                params.all_tickers = extractedTickers;
            } else {
                // Pas de ticker trouv√© - l'outil √©chouera probablement
                console.warn(`‚ö†Ô∏è Tool ${tool.id} requires ticker but none found`);
                return null; // Retourner null pour skip cet outil
            }
        }

        // Pour calculator: NE PAS l'utiliser si pas de donn√©es pour calculer
        if (tool.id === 'calculator') {
            // Calculator n√©cessite 'operation' ET 'values'
            // Si on n'a pas de donn√©es √† calculer, skip
            const hasCalculationRequest = userMessage.toLowerCase().match(/calcul|ratio|pe|dividend|market cap|croissance/);

            if (!hasCalculationRequest) {
                console.log('‚è≠Ô∏è Skipping calculator - no calculation requested');
                return null; // Skip calculator
            }

            // Si calcul demand√©, essayer d'extraire les param√®tres
            if (userMessage.toLowerCase().includes('pe') || userMessage.toLowerCase().includes('p/e')) {
                params.operation = 'pe_ratio';
            } else if (userMessage.toLowerCase().includes('dividend')) {
                params.operation = 'dividend_yield';
            } else if (userMessage.toLowerCase().includes('market cap')) {
                params.operation = 'market_cap';
            } else {
                params.operation = 'pe_ratio'; // D√©faut
            }

            // Pour values, on ne peut pas les deviner - skip si pas de donn√©es
            if (!context.stockData || !context.stockData[extractedTickers[0]]) {
                console.log('‚è≠Ô∏è Skipping calculator - no stock data available for calculation');
                return null;
            }

            // Essayer d'extraire les valeurs depuis stockData
            const stockInfo = context.stockData[extractedTickers[0]];
            if (params.operation === 'pe_ratio' && stockInfo.price && stockInfo.eps) {
                params.values = {
                    price: stockInfo.price,
                    earnings_per_share: stockInfo.eps
                };
            } else {
                // Pas assez de donn√©es pour calculator
                console.log('‚è≠Ô∏è Skipping calculator - insufficient data for calculation');
                return null;
            }
        }

        // Pour les outils qui n√©cessitent une date
        if (tool.parameters.date) {
            params.date = new Date().toISOString().split('T')[0];
        }

        return params;
    }

    /**
     * Extraction de TOUS les tickers pertinents depuis le message et le contexte
     */
    _extractAllTickers(userMessage, context) {
        const tickers = new Set();

        // 1. Tickers depuis le contexte (priorit√©)
        if (context.extracted_tickers && context.extracted_tickers.length > 0) {
            // Depuis l'analyse d'intention
            context.extracted_tickers.forEach(t => tickers.add(t.toUpperCase()));
        } else if (context.tickers && context.tickers.length > 0) {
            // Depuis le contexte fourni par le frontend
            context.tickers.forEach(t => tickers.add(t.toUpperCase()));
        }

        // 2. Tickers explicitement mentionn√©s dans le message
        const tickerPattern = /\b([A-Z]{1,5})\b/g;
        const matches = userMessage.match(tickerPattern);
        if (matches) {
            matches.forEach(match => {
                // V√©rifier si c'est un ticker valide (2-5 lettres)
                if (match.length >= 2 && match.length <= 5) {
                    tickers.add(match);
                }
            });
        }

        // 3. Mapping de noms de compagnies vers tickers
        const companyToTicker = {
            'apple': 'AAPL',
            'microsoft': 'MSFT',
            'google': 'GOOGL',
            'alphabet': 'GOOGL',
            'amazon': 'AMZN',
            'tesla': 'TSLA',
            'meta': 'META',
            'facebook': 'META',
            'nvidia': 'NVDA',
            'amd': 'AMD',
            'intel': 'INTC',
            'netflix': 'NFLX',
            'disney': 'DIS'
        };

        const messageLower = userMessage.toLowerCase();
        Object.entries(companyToTicker).forEach(([company, ticker]) => {
            if (messageLower.includes(company)) {
                tickers.add(ticker);
            }
        });

        return Array.from(tickers);
    }

    /**
     * G√©n√©ration de la r√©ponse finale avec SMART ROUTING (Perplexity/Gemini/Claude)
     */
    async _generate_response(userMessage, toolResults, context, intentData = null) {
        try {
            const outputMode = context.output_mode || 'chat';
            console.log(`üéØ Generating response for mode: ${outputMode}`);

            // Pr√©paration du contexte
            // IMPORTANT: Inclure TOUS les outils qui ont retourn√© des donn√©es, m√™me si is_reliable: false
            // Emma doit voir les donn√©es pour pouvoir les analyser et en parler
            const toolsData = toolResults
                .filter(r => r.data && !r.skipped) // Inclure tous les outils avec donn√©es (m√™me is_reliable: false)
                .map(r => ({
                    tool: r.tool_id,
                    data: r.data,
                    is_reliable: r.is_reliable,
                    success: r.success
                }));

            const conversationContext = this.conversationHistory.slice(-5); // 5 derniers √©changes

            // üß† INTELLIGENT MODE DETECTION: Ajuster outputMode selon complexit√©
            const detectedMode = this._detectComplexity(userMessage, intentData, context);
            if (detectedMode && detectedMode !== outputMode) {
                console.log(`üß† Intelligence: ${outputMode} ‚Üí ${detectedMode} (auto-d√©tect√©)`);
                outputMode = detectedMode;
            }

            // üéØ SMART ROUTER: S√©lectionner le meilleur mod√®le
            const modelSelection = this._selectModel(intentData, outputMode, toolsData);
            console.log(`ü§ñ Selected model: ${modelSelection.model} (${modelSelection.reason})`);

            // Construire le prompt appropri√©
            const prompt = this._buildPerplexityPrompt(
                userMessage,
                toolsData,
                conversationContext,
                context,
                intentData
            );

            let response;

            // Router vers le bon mod√®le
            if (modelSelection.model === 'claude') {
                // CLAUDE: Briefings premium
                response = await this._call_claude(prompt, outputMode);
            } else if (modelSelection.model === 'gemini') {
                // GEMINI: Questions conceptuelles (gratuit)
                response = await this._call_gemini(prompt, outputMode);
            } else {
                // PERPLEXITY: Donn√©es factuelles avec sources (default)
                response = await this._call_perplexity(prompt, outputMode, modelSelection.recency);
            }

            // Post-traitement selon le mode
            if (outputMode === 'data') {
                // Valider et parser le JSON
                response = this._validateAndParseJSON(response);
            } else if (outputMode === 'briefing') {
                // Nettoyer le Markdown (enlever √©ventuels artifacts)
                response = this._cleanMarkdown(response);
            }

            // üõ°Ô∏è FRESH DATA GUARD: Valider que les donn√©es factuelles ont des sources
            let validation = null;
            if (outputMode === 'chat' && modelSelection.model === 'perplexity') {
                validation = this._validateFreshData(response, intentData);
                console.log(`üõ°Ô∏è FreshDataGuard: Confidence ${(validation.confidence * 100).toFixed(0)}%, Sources: ${validation.source_types_found}`);

                if (!validation.passed) {
                    console.warn('‚ö†Ô∏è FreshDataGuard: Response lacks sources, retrying...');
                    // Retry avec prompt renforc√©
                    const reinforcedPrompt = `${prompt}\n\n‚ö†Ô∏è CRITICAL: You MUST include sources for all factual claims. Do not provide generic answers without sources.`;
                    response = await this._call_perplexity(reinforcedPrompt, outputMode, modelSelection.recency);
                    // Re-valider
                    validation = this._validateFreshData(response, intentData);
                    console.log(`üõ°Ô∏è FreshDataGuard (retry): Confidence ${(validation.confidence * 100).toFixed(0)}%, Sources: ${validation.source_types_found}`);
                }
            }

            // Retourner r√©ponse avec validation et mod√®le utilis√©
            return {
                response,
                validation,
                model: modelSelection.model,  // Ajout du mod√®le pour affichage dans l'UI
                model_reason: modelSelection.reason
            };

        } catch (error) {
            console.error('‚ùå Response generation failed:', error);

            // R√©ponse de fallback bas√©e sur les donn√©es des outils
            const fallbackResponse = this._generateFallbackResponse(userMessage, toolResults, context.output_mode);
            return {
                response: fallbackResponse,
                validation: { passed: false, confidence: 0.3, reason: 'Fallback response' }
            };
        }
    }

    /**
     * üõ°Ô∏è FRESH DATA GUARD - Valide la pr√©sence de sources pour donn√©es factuelles
     * Garantit la fiabilit√© et la transparence des r√©ponses d'Emma
     */
    _validateFreshData(response, intentData) {
        // Intents qui N√âCESSITENT des sources
        const needsSourcesIntents = [
            'stock_price',
            'fundamentals',
            'news',
            'comprehensive_analysis',
            'comparative_analysis',
            'earnings',
            'market_overview',
            'recommendation'
        ];

        const intent = intentData?.intent || 'unknown';

        // Si intent ne n√©cessite pas de sources, passer
        if (!needsSourcesIntents.includes(intent)) {
            return {
                passed: true,
                confidence: 0.7,
                reason: 'Intent does not require sources'
            };
        }

        // V√©rifier la pr√©sence de sources dans la r√©ponse
        const hasSourcePatterns = [
            /\[SOURCE:/i,
            /\[CHART:/i,
            /\[TABLE:/i,
            /\(https?:\/\//i, // URLs
            /Bloomberg|Reuters|La Presse|BNN|CNBC|Financial Times|Wall Street Journal/i,
            /Donn√©es de march√©:|Sources:/i
        ];

        const hasSources = hasSourcePatterns.some(pattern => pattern.test(response));

        // Calculer score de confiance
        let confidence = 0.5; // Base

        if (hasSources) {
            confidence = 0.9; // Haute confiance si sources pr√©sentes

            // Bonus: Plusieurs types de sources
            const sourceTypeCount = hasSourcePatterns.filter(pattern => pattern.test(response)).length;
            if (sourceTypeCount >= 3) confidence = 0.95;
            if (sourceTypeCount >= 5) confidence = 0.98;
        }

        // V√©rifier dates r√©centes (bonus confiance)
        const hasRecentDate = /202[4-5]|janvier|f√©vrier|mars|avril|mai|juin|juillet|ao√ªt|septembre|octobre|novembre|d√©cembre/i.test(response);
        if (hasRecentDate) confidence += 0.02;

        return {
            passed: hasSources,
            confidence: Math.min(1.0, confidence),
            reason: hasSources ? 'Sources verified' : 'Missing sources for factual data',
            source_types_found: hasSourcePatterns.filter(pattern => pattern.test(response)).length
        };
    }

    /**
     * Validation et parsing JSON (MODE DATA)
     */
    _validateAndParseJSON(response) {
        try {
            console.log('üîç Validating JSON response...');

            // Extraire JSON si du texte avant/apr√®s
            const jsonMatch = response.match(/\{[\s\S]*\}/);
            if (!jsonMatch) {
                console.error('‚ùå No JSON found in response');
                return '{}'; // Fallback: objet vide
            }

            // Parser pour valider
            const parsed = JSON.parse(jsonMatch[0]);

            // Retourner JSON stringifi√© proprement
            console.log('‚úÖ JSON validated successfully');
            return JSON.stringify(parsed, null, 2);

        } catch (error) {
            console.error('‚ùå JSON validation failed:', error.message);
            console.error('Response was:', response.substring(0, 200));
            return '{}'; // Fallback: objet vide
        }
    }

    /**
     * Nettoyage Markdown (MODE BRIEFING)
     */
    _cleanMarkdown(markdown) {
        // Enlever √©ventuels code blocks markdown si pr√©sents
        let cleaned = markdown.replace(/^```markdown\n/, '').replace(/\n```$/, '');

        // Nettoyer espaces multiples
        cleaned = cleaned.replace(/\n{3,}/g, '\n\n');

        return cleaned.trim();
    }

    /**
     * Construction du prompt pour Perplexity (ROUTER - 3 MODES)
     */
    _buildPerplexityPrompt(userMessage, toolsData, conversationContext, context, intentData = null) {
        const outputMode = context.output_mode || 'chat'; // Default: chat
        console.log(`üéØ Building prompt for mode: ${outputMode}`);

        switch (outputMode) {
            case 'chat':
                return this._buildChatPrompt(userMessage, toolsData, conversationContext, intentData);

            case 'data':
                return this._buildDataPrompt(userMessage, toolsData, context);

            case 'briefing':
                return this._buildBriefingPrompt(userMessage, toolsData, context, intentData);

            default:
                console.warn(`‚ö†Ô∏è Unknown output_mode: ${outputMode}, fallback to chat`);
                return this._buildChatPrompt(userMessage, toolsData, conversationContext, intentData);
        }
    }

    /**
     * MODE CHAT: R√©ponse conversationnelle naturelle
     */
    _buildChatPrompt(userMessage, toolsData, conversationContext, intentData) {
        const currentDate = new Date().toLocaleDateString('fr-FR', {
            weekday: 'long',
            year: 'numeric',
            month: 'long',
            day: 'numeric'
        });
        const currentDateTime = new Date().toISOString();

        let intentContext = '';
        if (intentData) {
            intentContext = `\nINTENTION D√âTECT√âE:
- Type: ${intentData.intent}
- Confiance: ${(intentData.confidence * 100).toFixed(0)}%
- R√©sum√©: ${intentData.user_intent_summary || 'Non sp√©cifi√©'}
- Tickers identifi√©s: ${intentData.tickers?.join(', ') || 'aucun'}\n`;
        }

        return `Tu es Emma, l'assistante financi√®re intelligente. R√©ponds en fran√ßais de mani√®re professionnelle et accessible.

üìÖ DATE ACTUELLE: ${currentDate} (${currentDateTime})
‚ö†Ô∏è CRITIQUE: Toutes les donn√©es doivent refl√©ter les informations les plus r√©centes. Si une donn√©e est dat√©e (ex: "au 8 ao√ªt"), pr√©cise clairement que c'est une donn√©e ancienne et cherche des informations plus r√©centes si disponibles.

CONTEXTE DE LA CONVERSATION:
${conversationContext.map(c => `- ${c.role}: ${c.content}`).join('\n')}
${intentContext}
DONN√âES DISPONIBLES DES OUTILS:
${toolsData.map(t => {
    const reliabilityNote = t.is_reliable === false ? ' [‚ö†Ô∏è SOURCE PARTIELLE - Utiliser avec prudence]' : '';
    return `- ${t.tool}${reliabilityNote}: ${JSON.stringify(t.data, null, 2)}`;
}).join('\n')}

QUESTION DE L'UTILISATEUR: ${userMessage}

INSTRUCTIONS CRITIQUES:
1. ‚ùå ‚ùå ‚ùå NE JAMAIS COPIER DU JSON BRUT DANS TA R√âPONSE ‚ùå ‚ùå ‚ùå
   - Les donn√©es JSON ci-dessus sont pour TON analyse SEULEMENT
   - Tu dois TOUJOURS transformer ces donn√©es en texte conversationnel fran√ßais
   - Exemple INTERDIT: "{\\"price\\": 245.67}"
   - Exemple CORRECT: "Le prix actuel est de 245,67$"

2. ‚úÖ TU ES UNE ANALYSTE, PAS UN ROBOT QUI AFFICHE DES DONN√âES
   - INTERPR√àTE les chiffres, ne les affiche pas juste
   - EXPLIQUE ce que signifient les donn√©es
   - DONNE des insights et du contexte

3. ‚úÖ TOUJOURS fournir une r√©ponse COMPL√àTE et UTILE bas√©e sur les donn√©es disponibles
4. ‚úÖ Utilise TOUTES les donn√©es fournies par les outils, M√äME si marqu√©es "[‚ö†Ô∏è SOURCE PARTIELLE]"
   - Les donn√©es partielles sont MEILLEURES que pas de donn√©es du tout
   - Analyse ce qui est disponible et fournis des insights bas√©s sur ces donn√©es
5. ‚úÖ Si un outil a retourn√© des donn√©es pour PLUSIEURS tickers (news_by_ticker, fundamentals_by_ticker):
   - Analyse CHAQUE ticker individuellement
   - Fournis un r√©sum√© pour CHAQUE compagnie mentionn√©e
   - N'ignore PAS les tickers - ils sont tous importants
6. ‚ùå NE JAMAIS dire "aucune donn√©e disponible" si des outils ont retourn√© des donn√©es (m√™me partielles)
7. ‚ùå NE JAMAIS demander de clarifications - fournis directement l'analyse
8. ‚ö†Ô∏è IMPORTANT: V√©rifie les dates des donn√©es - signale si anciennes (> 1 mois) et mentionne la date actuelle: ${currentDate}
9. Cite tes sources (outils utilis√©s) en fin de r√©ponse
10. Ton: professionnel mais accessible, comme une vraie analyste financi√®re
${intentData ? `11. L'intention d√©tect√©e: ${intentData.intent} - ${intentData.intent === 'comprehensive_analysis' ? 'fournis une analyse COMPL√àTE pour chaque ticker avec prix, fondamentaux, et actualit√©s' : 'r√©ponds en analysant tous les tickers pertinents'}` : ''}

üìä GRAPHIQUES ET VISUALISATIONS - R√àGLES STRICTES ET OBLIGATOIRES:

‚ö†Ô∏è CRITIQUE: Si l'utilisateur demande des graphiques, images, charts, visualisations OU mentionne "en images", tu DOIS utiliser les TAGS EXACTS ci-dessous.

**Tags disponibles (FORMAT EXACT OBLIGATOIRE):**

**Graphiques Finviz:**
- [CHART:FINVIZ:TICKER] ‚Üí Graphique Finviz (ex: [CHART:FINVIZ:AAPL])
- [CHART:FINVIZ:SECTORS] ‚Üí Heatmap sectorielle

**Widgets TradingView:**
- [CHART:TRADINGVIEW:EXCHANGE:TICKER] ‚Üí Graphique complet interactif (ex: [CHART:TRADINGVIEW:NASDAQ:MSFT])
- [MINI:TRADINGVIEW:TICKER] ‚Üí Mini-graphique compact (ex: [MINI:TRADINGVIEW:AAPL])
- [TECHNICAL:TRADINGVIEW:TICKER] ‚Üí Analyse technique avec signal achat/vente (ex: [TECHNICAL:TRADINGVIEW:AAPL])
- [QUOTE:TRADINGVIEW:TICKER] ‚Üí Citation simple avec prix actuel (ex: [QUOTE:TRADINGVIEW:AAPL])
- [TAPE:TRADINGVIEW:TICKER1,TICKER2,TICKER3] ‚Üí Bandeau watchlist temps r√©el (ex: [TAPE:TRADINGVIEW:AAPL,MSFT,GOOGL])
- [OVERVIEW:TRADINGVIEW] ‚Üí Vue d'ensemble multi-march√©s (indices, forex, crypto)

**Autres:**
- [LOGO:TICKER] ‚Üí Logo entreprise (ex: [LOGO:AAPL])

**‚ùå ‚ùå ‚ùå FORMATS INTERDITS - NE JAMAIS UTILISER:**
‚ùå "üìä Finviz Chart: AAPL"
‚ùå "Voici le graphique Finviz pour AAPL"
‚ùå "AAPL Chart"
‚ùå "Graphique de AAPL disponible sur Finviz"
‚ùå "Vous pouvez voir le graphique de..."
‚ùå Tout texte descriptif au lieu des tags

**‚úÖ ‚úÖ ‚úÖ FORMAT CORRECT - TOUJOURS UTILISER:**
‚úÖ [CHART:FINVIZ:AAPL]
‚úÖ [MINI:TRADINGVIEW:AAPL]
‚úÖ [TECHNICAL:TRADINGVIEW:AAPL]
‚úÖ [QUOTE:TRADINGVIEW:MSFT]
‚úÖ [TAPE:TRADINGVIEW:AAPL,MSFT,GOOGL]
‚úÖ [OVERVIEW:TRADINGVIEW]
‚úÖ [CHART:FINVIZ:SECTORS]
‚úÖ [LOGO:AAPL]

**R√àGLES ABSOLUES:**
1. ‚úÖ COPIER-COLLER le tag EXACT entre crochets: [CHART:FINVIZ:TICKER]
2. ‚úÖ Remplacer TICKER par le symbole boursier en MAJUSCULES
3. ‚úÖ Placer le tag sur une LIGNE S√âPAR√âE dans ton texte
4. ‚ùå NE JAMAIS modifier le format du tag
5. ‚ùå NE JAMAIS ajouter d'emoji ou de texte dans le tag
6. ‚ùå NE JAMAIS expliquer le tag, juste l'ins√©rer

**EXEMPLES CORRECTS D'INT√âGRATION:**

EXEMPLE 1 - Analyse d'une action:
"Voici l'analyse de Apple (AAPL):

Le titre se n√©gocie √† 245,67$ (+2,34%).

[CHART:FINVIZ:AAPL]

Le graphique montre une tendance haussi√®re..."

EXEMPLE 2 - Analyse de plusieurs actions:
"Analyse comparative AAPL vs MSFT:

**Apple (AAPL):** 245,67$

[CHART:FINVIZ:AAPL]

**Microsoft (MSFT):** 525,76$

[CHART:FINVIZ:MSFT]"

EXEMPLE 3 - Heatmap sectorielle:
"Performance des secteurs:

[CHART:FINVIZ:SECTORS]

Le secteur tech domine avec +1,2%..."

EXEMPLE 4 - Analyse technique rapide:
"Signal technique pour Microsoft:

[QUOTE:TRADINGVIEW:MSFT]

[TECHNICAL:TRADINGVIEW:MSFT]

L'analyse technique montre un signal d'achat mod√©r√©..."

EXEMPLE 5 - Vue d'ensemble du march√©:
"Contexte des march√©s aujourd'hui:

[OVERVIEW:TRADINGVIEW]

Les indices am√©ricains sont en hausse..."

EXEMPLE 6 - Watchlist multiple:
"Voici votre watchlist en temps r√©el:

[TAPE:TRADINGVIEW:AAPL,MSFT,GOOGL,AMZN,TSLA]

D√©tails pour Apple:
[MINI:TRADINGVIEW:AAPL]"

‚ö†Ô∏è RAPPEL FINAL: Si "graphique", "image", "chart", "visualisation" ou "en images" est mentionn√©, tu DOIS inclure AU MOINS UN tag [CHART:...] ou widget TradingView dans ta r√©ponse. C'est OBLIGATOIRE.

EXEMPLE DE BONNE R√âPONSE (si demande sur plusieurs tickers):
"Voici une analyse des initiatives IA r√©centes pour les compagnies de l'√©quipe:

**GOOGL (Alphabet/Google)**
- Initiative IA: [analyse bas√©e sur les news r√©cup√©r√©es]
- Source: [d√©tails de la news avec date]

**T (AT&T)**
- Initiative IA: [analyse bas√©e sur les donn√©es disponibles]
...

[Continue pour TOUS les tickers dans les donn√©es]"

R√âPONSE:`;
    }

    /**
     * MODE DATA: JSON structur√© SEULEMENT
     */
    _buildDataPrompt(userMessage, toolsData, context) {
        const tickers = context.tickers || context.key_tickers || [];
        const fieldsRequested = context.fields_requested || [];

        return `Tu es Emma Data Extractor. Extrait et structure les donn√©es demand√©es en JSON STRICT.

DONN√âES DISPONIBLES DES OUTILS:
${toolsData.map(t => `- ${t.tool}: ${JSON.stringify(t.data, null, 2)}`).join('\n')}

DEMANDE: ${userMessage}

TICKERS DEMAND√âS: ${tickers.join(', ') || 'tous disponibles'}
CHAMPS DEMAND√âS: ${fieldsRequested.join(', ') || 'tous pertinents'}

INSTRUCTIONS CRITIQUES:
1. RETOURNER UNIQUEMENT DU JSON VALIDE - PAS DE TEXTE AVANT OU APR√àS
2. Structure: { "TICKER": { "field": value, ... } }
3. Inclure SEULEMENT les champs demand√©s ou pertinents au contexte
4. Valeurs num√©riques en NUMBER, pas en STRING
5. Si donn√©e manquante: utiliser null
6. Pas de commentaires, pas d'explications, SEULEMENT JSON
7. Utiliser les noms de champs anglais standards: price, pe, volume, marketCap, eps, etc.

EXEMPLE FORMAT ATTENDU:
{
  "AAPL": {
    "price": 245.67,
    "change": 5.67,
    "changePercent": 2.34,
    "volume": 58234567,
    "marketCap": 3850000000000,
    "pe": 32.4,
    "eps": 7.58
  },
  "MSFT": {
    "price": 428.32,
    "change": 3.21,
    "changePercent": 0.75,
    "volume": 24567890,
    "marketCap": 3200000000000,
    "pe": 38.1,
    "eps": 11.24
  }
}

R√âPONSE JSON:`;
    }

    /**
     * MODE BRIEFING: Analyse d√©taill√©e pour email
     */
    _buildBriefingPrompt(userMessage, toolsData, context, intentData) {
        const currentDate = new Date().toLocaleDateString('fr-FR', {
            weekday: 'long',
            year: 'numeric',
            month: 'long',
            day: 'numeric'
        });
        const currentDateTime = new Date().toISOString();
        const briefingType = context.briefing_type || context.type || 'general';
        const importanceLevel = intentData?.importance_level || context.importance_level || 5;
        const trendingTopics = intentData?.trending_topics || [];

        return `Tu es Emma Financial Analyst. R√©dige une analyse approfondie MULTIM√âDIA pour un briefing ${briefingType}.

üìÖ DATE ACTUELLE: ${currentDate} (${currentDateTime})
‚ö†Ô∏è CRITIQUE: Ce briefing doit refl√©ter les donn√©es du ${currentDate}. Toutes les dates mentionn√©es doivent √™tre v√©rifi√©es et corrig√©es si anciennes.

DONN√âES DISPONIBLES DES OUTILS:
${toolsData.map(t => `- ${t.tool}: ${JSON.stringify(t.data, null, 2)}`).join('\n')}

CONTEXTE: ${userMessage}

INTENT D√âTECT√â:
- Type: ${intentData?.intent || 'market_overview'}
- Importance: ${importanceLevel}/10
- Trending Topics: ${trendingTopics.join(', ') || 'N/A'}

TYPE DE BRIEFING: ${briefingType}

INSTRUCTIONS PRINCIPALES:
1. R√©dige une analyse D√âTAILL√âE et PROFESSIONNELLE (1500-2000 mots minimum)
2. Structure OBLIGATOIRE avec sections claires (##, ###)
3. Inclure des DONN√âES CHIFFR√âES pr√©cises (prix, %, volumes, etc.)
4. Ton: Professionnel institutionnel
5. Focus sur l'ACTIONNABLE et les INSIGHTS
6. Format MARKDOWN avec √©mojis appropri√©s (üìä, üìà, ‚ö†Ô∏è, etc.)
7. Si importance >= 8: commencer par une section BREAKING avec les √©v√©nements majeurs

üé® INSTRUCTIONS MULTIM√âDIAS (CRITIQUE):

A) SOURCES WEB CR√âDIBLES - Cherche et inclus des liens vers:
   - Bloomberg: https://www.bloomberg.com/quote/[TICKER]
   - La Presse (Canada): https://www.lapresse.ca/affaires/
   - Financial Times: https://www.ft.com/markets
   - Reuters: https://www.reuters.com/markets/
   - Wall Street Journal: https://www.wsj.com/market-data
   - CNBC: https://www.cnbc.com/quotes/[TICKER]
   - BNN Bloomberg (Canada): https://www.bnnbloomberg.ca/

B) GRAPHIQUES ET CHARTS - Inclus URLs de graphiques:
   üìà TradingView: [CHART:TRADINGVIEW:NASDAQ:TICKER]
   üìä Finviz: [CHART:FINVIZ:TICKER]
   üå°Ô∏è Heatmap sectorielle: [CHART:FINVIZ:SECTORS]

C) TABLEAUX DE DONN√âES - Cr√©e des tableaux HTML pour:
   - Performance tickers (Prix, Var %, Volume, MarketCap)
   - R√©sultats vs attentes (Actuel, Consensus, Surprise %)
   - Niveaux techniques (Support, R√©sistance, RSI, MACD)

   Format: [TABLE:NOM_TABLE|Col1,Col2,Col3|Val1,Val2,Val3|Val4,Val5,Val6]

D) IMAGES ET VISUELS:
   - Logos entreprises: [LOGO:TICKER]
   - Screenshots charts: [SCREENSHOT:TICKER:TIMEFRAME]
   - Timeline √©v√©nements: [TIMELINE:EVENTS]

E) LIENS SOURCES - Pour CHAQUE donn√©e/affirmation, fournis URL compl√®te
   Format: [SOURCE:NOM_SOURCE|URL_COMPLETE]

STRUCTURE ATTENDUE:

## üìä [Titre Principal Contextualis√©]

**R√©sum√© Ex√©cutif:** [2-3 phrases capturant l'essentiel de l'analyse]

[TABLE:PERFORMANCE_INDICES|Indice,Valeur,Variation %|S&P 500,5825.23,+0.45|NASDAQ,18456.32,+0.82]

### üìà Performance du Jour
[Analyse d√©taill√©e des mouvements de prix, volumes, catalyseurs du jour]

[CHART:FINVIZ:SECTORS]

**Indices majeurs:**
- S&P 500: [donn√©es] ([SOURCE:Bloomberg|https://www.bloomberg.com/quote/SPX:IND])
- NASDAQ: [donn√©es] ([SOURCE:CNBC|https://www.cnbc.com/quotes/.IXIC])
- DOW: [donn√©es]

**Actions cl√©s:**
[TABLE:TOP_MOVERS|Ticker,Prix,Var %,Volume|AAPL,247.25,-0.84%,58.2M|TSLA,245.67,+2.34%,125.3M]

### üíº Analyse Fondamentale
[M√©triques cl√©s avec tableaux comparatifs]

[TABLE:FUNDAMENTALS|Ticker,PE,EPS,Revenue Growth|AAPL,32.4,7.58,+8.5%|MSFT,38.1,11.24,+12.3%]

[SOURCE:Financial Times|https://www.ft.com/content/...]

### üìâ Analyse Technique
[Indicateurs techniques et niveaux cl√©s]

[CHART:TRADINGVIEW:NASDAQ:AAPL]

[TABLE:TECHNICAL_LEVELS|Ticker,RSI,MACD,Support,R√©sistance|AAPL,58.2,Positif,240,255]

### üì∞ Actualit√©s et Catalyseurs
[News importantes avec impact march√©]

**Principales actualit√©s:**
1. [Titre] ([SOURCE:La Presse|https://www.lapresse.ca/affaires/...])
2. [Titre] ([SOURCE:Reuters|https://www.reuters.com/markets/...])
3. [Titre] ([SOURCE:BNN Bloomberg|https://www.bnnbloomberg.ca/...])

[TIMELINE:EVENTS]

### üéØ Recommandations et Points de Surveillance
[Insights actionnables avec niveaux pr√©cis]

[TABLE:RECOMMENDATIONS|Action,Entry,Stop Loss,Target,Ratio R/R|AAPL,245-248,240,265,1:3.4]

---
**Sources Compl√®tes:**
- Donn√©es de march√©: Polygon.io, FMP, Finnhub
- Actualit√©s: [SOURCE:Bloomberg|URL], [SOURCE:Reuters|URL], [SOURCE:La Presse|URL]
- Charts: TradingView, Finviz
- Analyses: Emma Agent + Perplexity AI

R√âPONSE MARKDOWN ENRICHIE:`;
    }

    /**
     * Appel √† l'API Perplexity (avec recency filter)
     */
    async _call_perplexity(prompt, outputMode = 'chat', recency = 'month') {
        try {
            // üéì TOUS LES UTILISATEURS SONT EXPERTS: Param√®tres g√©n√©reux par d√©faut
            let maxTokens = 4000;  // Default g√©n√©reux pour utilisateurs experts (√©tait 1000)
            let temperature = 0.7; // Default cr√©atif et flexible

            if (outputMode === 'briefing') {
                maxTokens = 6000;  // Briefings tr√®s d√©taill√©s
                temperature = 0.6; // √âquilibr√©: d√©tail + cr√©ativit√©
            } else if (outputMode === 'data') {
                maxTokens = 2000;  // JSON complexe avec contexte (√©tait 500)
                temperature = 0.3; // D√©terministe pour donn√©es structur√©es
            } else if (outputMode === 'comprehensive' || outputMode === 'expert') {
                // Mode analyse approfondie maximale
                maxTokens = 8000;  // Maximum pour analyses exhaustives
                temperature = 0.8; // Plus cr√©atif et exploratoire
            }

            const requestBody = {
                model: 'sonar-pro',  // Mod√®le premium Perplexity (Jan 2025) - Meilleure qualit√©, plus de citations, recherche approfondie
                messages: [
                    {
                        role: 'system',
                        content: outputMode === 'data'
                            ? 'Tu es Emma Data Extractor. Retourne UNIQUEMENT du JSON valide, pas de texte explicatif.'
                            : 'Tu es Emma, une assistante financi√®re experte et analyste professionnelle.\n\nR√àGLES CRITIQUES:\n1. ‚ùå NE JAMAIS retourner du JSON brut ou du code dans tes r√©ponses\n2. ‚úÖ TOUJOURS analyser et expliquer les donn√©es de mani√®re conversationnelle en fran√ßais\n3. ‚úÖ TOUJOURS agir en tant qu\'analyste financi√®re qui INTERPR√àTE les donn√©es, pas juste les affiche\n4. ‚úÖ Ton style: professionnel, accessible, p√©dagogique\n5. ‚úÖ Structure tes r√©ponses avec des paragraphes, des bullet points, et des insights\n6. ‚ùå Si tu vois du JSON dans le prompt, c\'est pour TON analyse - ne le copie JAMAIS tel quel dans ta r√©ponse\n\nExemple CORRECT: "Apple (AAPL) affiche une performance solide avec un prix de 245,67$, en hausse de 2,36% aujourd\'hui..."\n\nExemple INCORRECT: "{\\"AAPL\\": {\\"price\\": 245.67, \\"change\\": 5.67}}"'
                    },
                    {
                        role: 'user',
                        content: prompt
                    }
                ],
                max_tokens: maxTokens,
                temperature: temperature
            };

            // Ajouter recency filter si disponible
            if (recency) {
                requestBody.search_recency_filter = recency; // hour, day, week, month, year
                console.log(`üïê Using recency filter: ${recency}`);
            }

            const response = await fetch('https://api.perplexity.ai/chat/completions', {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${process.env.PERPLEXITY_API_KEY}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(requestBody)
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                console.error('‚ùå Perplexity API error details:', errorData);
                throw new Error(`Perplexity API error: ${response.status} - ${errorData.error?.message || response.statusText}`);
            }

            const data = await response.json();
            return data.choices[0].message.content;

        } catch (error) {
            console.error('‚ùå Perplexity API error:', error);
            throw new Error(`Erreur de communication avec Perplexity: ${error.message}`);
        }
    }

    /**
     * Appel √† Gemini (gratuit) pour questions conceptuelles
     */
    async _call_gemini(prompt, outputMode = 'chat') {
        try {
            if (!process.env.GEMINI_API_KEY) {
                throw new Error('GEMINI_API_KEY not configured');
            }

            // üéì TOUS LES UTILISATEURS SONT EXPERTS: Param√®tres g√©n√©reux par d√©faut
            let maxTokens = 4000; // Default g√©n√©reux pour utilisateurs experts (√©tait 1000)
            let temperature = 0.7; // Default cr√©atif et flexible

            if (outputMode === 'data') {
                maxTokens = 2000; // JSON complexe avec contexte (√©tait 500)
                temperature = 0.3; // D√©terministe pour donn√©es structur√©es
            } else if (outputMode === 'briefing') {
                maxTokens = 6000; // Briefings tr√®s d√©taill√©s
                temperature = 0.6; // √âquilibr√©
            } else if (outputMode === 'comprehensive' || outputMode === 'expert') {
                maxTokens = 8000; // Mode analyse approfondie maximale
                temperature = 0.8; // Plus cr√©atif
            }

            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${process.env.GEMINI_API_KEY}`;

            // Ajouter instructions syst√®me pour mode conversationnel
            const systemInstructions = outputMode === 'data'
                ? 'Tu es Emma Data Extractor. Retourne UNIQUEMENT du JSON valide.'
                : `Tu es Emma, analyste financi√®re experte.

R√àGLES CRITIQUES:
- ‚ùå NE JAMAIS retourner du JSON brut ou du code
- ‚úÖ TOUJOURS √™tre conversationnelle et analyser les donn√©es
- ‚úÖ Tu es une ANALYSTE qui INTERPR√àTE, pas un robot qui affiche des donn√©es
- ‚úÖ R√©ponds en fran√ßais professionnel et accessible

`;

            const fullPrompt = systemInstructions + prompt;

            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    contents: [{
                        parts: [{ text: fullPrompt }]
                    }],
                    generationConfig: {
                        temperature: temperature,
                        maxOutputTokens: maxTokens,
                        candidateCount: 1
                    }
                })
            });

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`Gemini API error: ${response.status} - ${errorText}`);
            }

            const data = await response.json();
            const text = data.candidates?.[0]?.content?.parts?.[0]?.text || '';

            if (!text) {
                throw new Error('No response from Gemini');
            }

            return text;

        } catch (error) {
            console.error('‚ùå Gemini API error:', error);
            throw new Error(`Erreur de communication avec Gemini: ${error.message}`);
        }
    }

    /**
     * Appel √† Claude (premium) pour briefings et r√©daction
     */
    async _call_claude(prompt, outputMode = 'briefing') {
        try {
            if (!process.env.ANTHROPIC_API_KEY) {
                throw new Error('ANTHROPIC_API_KEY not configured');
            }

            // üéì TOUS LES UTILISATEURS SONT EXPERTS: Param√®tres g√©n√©reux par d√©faut
            let maxTokens = 4000; // Default g√©n√©reux pour utilisateurs experts (√©tait 1000)
            let temperature = 0.6; // Default √©quilibr√©

            if (outputMode === 'briefing') {
                maxTokens = 6000; // Briefings tr√®s d√©taill√©s
                temperature = 0.5; // D√©terministe pour √©criture professionnelle
            } else if (outputMode === 'data') {
                maxTokens = 2000; // JSON complexe avec contexte (√©tait 500)
                temperature = 0.3; // Tr√®s d√©terministe
            } else if (outputMode === 'comprehensive' || outputMode === 'expert') {
                maxTokens = 8000; // Mode analyse approfondie maximale
                temperature = 0.7; // Plus cr√©atif et nuanc√©
            }

            // System prompt pour Claude
            const systemPrompt = outputMode === 'data'
                ? 'Tu es Emma Data Extractor. Retourne UNIQUEMENT du JSON valide, pas de texte explicatif.'
                : `Tu es Emma, analyste financi√®re experte et r√©dactrice professionnelle.

R√àGLES CRITIQUES:
- ‚ùå NE JAMAIS retourner du JSON brut ou du code dans tes r√©ponses
- ‚úÖ TOUJOURS analyser et interpr√©ter les donn√©es de mani√®re conversationnelle
- ‚úÖ TU ES UNE ANALYSTE qui R√âDIGE des briefings professionnels, pas un robot
- ‚úÖ Utilise un ton institutionnel, professionnel et accessible
- ‚úÖ Structure avec Markdown (##, ###, bullet points, tableaux)
- ‚úÖ Inclus des donn√©es chiffr√©es pr√©cises et contextualis√©es
- ‚úÖ Fournis des insights actionnables et des recommandations

Tu es utilis√©e principalement pour r√©diger des briefings quotidiens de haute qualit√©.`;

            const response = await fetch('https://api.anthropic.com/v1/messages', {
                method: 'POST',
                headers: {
                    'x-api-key': process.env.ANTHROPIC_API_KEY,
                    'anthropic-version': '2023-06-01',
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    model: 'claude-3-5-sonnet-20241022',
                    max_tokens: maxTokens,
                    temperature: temperature,
                    system: systemPrompt,
                    messages: [
                        {
                            role: 'user',
                            content: prompt
                        }
                    ]
                })
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(`Claude API error: ${response.status} - ${errorData.error?.message || response.statusText}`);
            }

            const data = await response.json();
            return data.content[0].text;

        } catch (error) {
            console.error('‚ùå Claude API error:', error);
            throw new Error(`Erreur de communication avec Claude: ${error.message}`);
        }
    }

    /**
     * R√©ponse de fallback si Perplexity √©choue (adapt√© selon mode)
     */
    _generateFallbackResponse(userMessage, toolResults, outputMode = 'chat') {
        const successfulResults = toolResults.filter(r => r.success && r.data);

        if (successfulResults.length === 0) {
            if (outputMode === 'data') {
                return '{}';
            }
            return "D√©sol√©, je n'ai pas pu r√©cup√©rer de donn√©es fiables pour r√©pondre √† votre question. Veuillez r√©essayer.";
        }

        // Mode DATA: retourner JSON
        if (outputMode === 'data') {
            const dataObj = {};
            successfulResults.forEach(result => {
                if (result.data && typeof result.data === 'object') {
                    Object.assign(dataObj, result.data);
                }
            });
            return JSON.stringify(dataObj, null, 2);
        }

        // Mode CHAT ou BRIEFING: retourner texte format√©
        let response = "Voici les informations que j'ai pu r√©cup√©rer :\n\n";

        successfulResults.forEach(result => {
            response += `**${result.tool_id}**: ${JSON.stringify(result.data, null, 2)}\n\n`;
        });

        response += "Note: Cette r√©ponse est bas√©e uniquement sur les donn√©es disponibles. Pour une analyse plus approfondie, veuillez reformuler votre question.";

        return response;
    }

    /**
     * Mise √† jour de l'historique de conversation
     */
    _updateConversationHistory(userMessage, response, toolResults) {
        this.conversationHistory.push({
            role: 'user',
            content: userMessage,
            timestamp: new Date().toISOString()
        });
        
        this.conversationHistory.push({
            role: 'assistant',
            content: response,
            tools_used: toolResults.map(r => r.tool_id),
            timestamp: new Date().toISOString()
        });
        
        // Limiter l'historique √† 20 √©changes (10 questions/r√©ponses)
        if (this.conversationHistory.length > 20) {
            this.conversationHistory = this.conversationHistory.slice(-20);
        }
    }

    /**
     * Mise √† jour des statistiques d'outil
     */
    _updateToolStats(toolId, success, executionTime, errorMessage = null) {
        if (!this.usageStats[toolId]) {
            this.usageStats[toolId] = {
                total_calls: 0,
                successful_calls: 0,
                failed_calls: 0,
                average_response_time_ms: 0,
                last_used: null,
                success_rate: 0,
                error_history: []
            };
        }
        
        const stats = this.usageStats[toolId];
        stats.total_calls++;
        stats.last_used = new Date().toISOString();
        
        if (success) {
            stats.successful_calls++;
        } else {
            stats.failed_calls++;
            if (errorMessage) {
                stats.error_history.push({
                    timestamp: new Date().toISOString(),
                    error: errorMessage
                });
                // Garder seulement les 10 derni√®res erreurs
                if (stats.error_history.length > 10) {
                    stats.error_history = stats.error_history.slice(-10);
                }
            }
        }
        
        // Calcul du taux de succ√®s
        stats.success_rate = stats.total_calls > 0 ? (stats.successful_calls / stats.total_calls) * 100 : 0;
        
        // Mise √† jour du temps de r√©ponse moyen
        if (executionTime > 0) {
            const totalTime = stats.average_response_time_ms * (stats.total_calls - 1) + executionTime;
            stats.average_response_time_ms = Math.round(totalTime / stats.total_calls);
        }
    }

    /**
     * Chargement de la configuration des outils
     */
    _loadToolsConfig() {
        try {
            const configPath = path.join(process.cwd(), 'config', 'tools_config.json');
            return JSON.parse(fs.readFileSync(configPath, 'utf8'));
        } catch (error) {
            console.error('‚ùå Failed to load tools config:', error);
            return { tools: [], config: {} };
        }
    }

    /**
     * Chargement des statistiques d'utilisation
     */
    _loadUsageStats() {
        try {
            const statsPath = path.join(process.cwd(), 'config', 'usage_stats.json');
            return JSON.parse(fs.readFileSync(statsPath, 'utf8'));
        } catch (error) {
            console.error('‚ùå Failed to load usage stats:', error);
            return {};
        }
    }

    /**
     * Sauvegarde des statistiques d'utilisation
     */
    _saveUsageStats() {
        try {
            const statsPath = path.join(process.cwd(), 'config', 'usage_stats.json');
            fs.writeFileSync(statsPath, JSON.stringify(this.usageStats, null, 2));
        } catch (error) {
            console.error('‚ùå Failed to save usage stats:', error);
        }
    }
}

// Instance globale de l'agent
let emmaAgent = null;

/**
 * Handler principal pour l'API Emma Agent
 */
export default async function handler(req, res) {
    // CORS headers
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
    res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');

    if (req.method === 'OPTIONS') {
        return res.status(200).end();
    }

    if (req.method !== 'POST') {
        return res.status(405).json({ error: 'Method not allowed' });
    }

    // V√©rifier que PERPLEXITY_API_KEY est configur√©e
    if (!process.env.PERPLEXITY_API_KEY) {
        console.error('‚ùå PERPLEXITY_API_KEY is not configured!');
        return res.status(503).json({
            success: false,
            error: 'PERPLEXITY_API_KEY non configur√©e',
            response: '‚öôÔ∏è Configuration manquante: La cl√© API Perplexity n\'est pas configur√©e dans Vercel. Veuillez ajouter PERPLEXITY_API_KEY dans les variables d\'environnement Vercel.',
            is_reliable: false
        });
    }

    try {
        // Initialisation de l'agent si n√©cessaire
        if (!emmaAgent) {
            emmaAgent = new SmartAgent();
        }

        const { message, context = {} } = req.body;
        
        if (!message) {
            return res.status(400).json({ error: 'Message is required' });
        }

        // Ajout du timestamp de d√©but
        context.start_time = Date.now();

        // Traitement de la requ√™te
        const result = await emmaAgent.processRequest(message, context);

        return res.status(200).json(result);

    } catch (error) {
        console.error('‚ùå Emma Agent API Error:', error);
        return res.status(500).json({
            success: false,
            error: error.message,
            response: "Erreur interne du serveur. Veuillez r√©essayer."
        });
    }
}
